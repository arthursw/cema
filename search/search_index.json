{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cema - Conda Environment Manager","text":"<p>Cema (Conda Environment MAnager) is a lightweight Python library for managing Conda environments.</p> <p>Cema can create Conda environments on demand, install dependencies, and execute arbitrary code within them. This makes it easy to build plugin systems or integrate external modules into an application without dependency conflicts, as each environment remains isolated.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>Automatic Environment Management: Create and configure environments on demand.</li> <li>Dependency Isolation: Install dependencies without conflicts.</li> <li>Embedded Execution: Run Python functions inside isolated environments.</li> <li>Micromamba: Cema uses a self-contained <code>micromamba</code> for fast and lightweight Conda environment handling.</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>To install Cema, simply run:</p> <pre><code>pip install cema\n</code></pre>"},{"location":"#usage","title":"\ud83d\ude80 Usage","text":""},{"location":"#minimal-example","title":"Minimal example","text":"<p>Here is a minimal example usage:</p> <pre><code>from cema.environment_manager import EnvironmentManager\n\n# Initialize the environment manager\nenvironmentManager = EnvironmentManager(\"micromamba/\")\n\n# Create and launch a Conda environment named \"numpy_env\"\nenv = environmentManager.create(\"numpy_env\", {\"pip\": [\"numpy==2.2.4\"]})\nenv.launch()\n\n# Import minimal_module in the environment (see minimal_module.py below)\nminimal_module = env.importModule(\"minimal_module.py\")\n# minimal_module is a proxy to minimal_module.py in the environment\narray = [1, 2, 3]\n# Execute the sum() function in the numpy_env environment and get the result\nresult = minimal_module.sum(array)\n\nprint(f\"Sum of {array} is {result}.\")\n\n# Clean up and exit the environment\nenv.exit()\n</code></pre> <p>With <code>minimal_module.py</code>:</p> <pre><code>def sum(x):\n    import numpy as np  # type: ignore\n    return int(np.sum(x))\n</code></pre>"},{"location":"#general-usage","title":"General usage","text":"<p>Cema allows you to interact with isolated Conda environments in two main ways:</p> <ol> <li>Simplified Execution (<code>env.importModule</code> / <code>env.execute</code>): Cema manages the communication details, providing a proxy object to call functions within the environment seamlessly. See the Getting Started.</li> <li>Manual Control (<code>env.executeCommands</code>): You run specific commands (like starting a Python script that listens for connections) and manage the inter-process communication yourself. See the advanced example.</li> </ol> <p>You can run those examples form the <code>examples/</code> folder in the repository.</p>"},{"location":"#how-it-works","title":"\ud83c\udf93 How It Works","text":"<p>Cema leverages Micromamba, a fast, native reimplementation of the Conda package manager.</p> <ol> <li>Micromamba Setup: When <code>EnvironmentManager</code> is initialized, it checks for a <code>micromamba</code> executable at the specified path (e.g., <code>\"micromamba/\"</code>). If not found, it downloads a self-contained Micromamba binary suitable for the current operating system and architecture into that directory. This means Cema doesn't require a pre-existing Conda/Mamba installation.</li> <li>Environment Creation: <code>create(name, dependencies)</code> uses Micromamba commands (<code>micromamba create -n name -c channel package ...</code>) to build a new, isolated Conda environment within the Micromamba prefix (e.g., <code>micromamba/envs/name</code>). Note that the main environemnt is returned if it already satisfies the required dependencies.</li> <li>Dependency Installation: Dependencies (Conda packages, Pip packages) are installed into the target environment using <code>micromamba install ...</code> and <code>pip install ...</code> (executed within the activated environment).</li> <li>Execution (<code>launch</code>/<code>execute</code>/<code>importModule</code>):<ul> <li><code>launch()</code> starts a helper Python script (<code>cema._internal.executor_server</code>) within the activated target environment using <code>subprocess.Popen</code>.</li> <li>This server listens on a local socket using <code>multiprocessing.connection.Listener</code>.</li> <li>The main process connects to this server using <code>multiprocessing.connection.Client</code>.</li> <li><code>execute(module, func, args)</code> sends a message containing the module path, function name, and arguments to the server.</li> <li>The server imports the module (if not already imported), executes the function with the provided arguments, and sends the result (or exception) back to the main process.</li> <li><code>importModule(module)</code> creates a proxy object in the main process. When methods are called on this proxy, it triggers the <code>execute</code> mechanism described above.</li> </ul> </li> <li>Direct Execution (<code>executeCommands</code>): This method directly activates the target environment and runs the provided shell commands using <code>subprocess.Popen</code> (no communication server involved here). The user is responsible for managing the launched process and any necessary communication.</li> <li>Isolation: Each environment created by Cema is fully isolated, preventing dependency conflicts between different environments or with the main application's environment.</li> </ol>"},{"location":"#under-the-hood","title":"\u2699\ufe0f Under the Hood","text":"<p>Cema uses the <code>EnvironmentManager.executeCommands()</code> for different operations (to create environments, install dependencies, etc).  Behind the scenes, this method creates and executes a temporary script (a bash script on Linux and Mac, and a PowerShell script on Windows) which looks like the following:</p> <pre><code># Install Micromamba (only if necessary)\ncd \"/path/to/examples/micromamba\"\necho \"Installing micromamba...\"\ncurl  -Ls https://micro.mamba.pm/api/micromamba/osx-arm64/latest | tar -xvj bin/micromamba\n\n# Initialize Micromamba\ncd \"/path/to/examples/micromamba\"\nexport MAMBA_ROOT_PREFIX=\"/path/to/examples/micromamba\"\neval \"$(bin/micromamba shell hook -s posix)\"\n\n# Create the cellpose environment\ncd \"/Users/amasson/Travail/cema/examples\"\nmicromamba --rc-file \"/path/to/examples/micromamba/.mambarc\" create -n cellpose python=3.12.7 -y\n\n# Activate the environment\ncd \"/path/to/examples/\"\nmicromamba activate cellpose\n\n# Install the dependencies\necho \"Installing conda dependencies...\"\nmicromamba --rc-file \"/path/to/examples/micromamba/.mambarc\" install \"cellpose==3.1.0\" -y\n\n# Execute optional custom commands\npython -u example_module.py\n</code></pre>"},{"location":"advanced_example/","title":"Advanced example","text":""},{"location":"advanced_example/#manual-communication-with-envexecutecommands","title":"Manual Communication with <code>env.executeCommands</code>","text":"<p>This example shows how to use Cema to run a specific script within the environment and manage the communication manually using Python's <code>multiprocessing.connection</code>. This gives you full control over the interaction protocol but requires more setup.</p> <p>Let's see the main script <code>advanced_example.py</code> step by step. </p>"},{"location":"advanced_example/#initialize-cema-and-logging","title":"Initialize Cema and Logging","text":"<p>We import necessary modules, including <code>Client</code> for manual connection and standard Python libraries like <code>subprocess</code>, <code>threading</code>, and <code>logging</code>. We also enable debug logging for Cema to see more internal details and initialize the <code>EnvironmentManager</code>.</p> <pre><code># main_script_manual.py\nfrom multiprocessing.connection import Client\nimport subprocess\nimport sys\nimport threading\nimport logging\nfrom pathlib import Path\nimport time\n\nfrom cema.environment_manager import EnvironmentManager\nfrom cema import logger\n\nlogger.setLogLevel(logging.DEBUG)\nenvironmentManager = EnvironmentManager(\"micromamba/\")\n</code></pre>"},{"location":"advanced_example/#create-the-environment","title":"Create the Environment","text":"<p>Similar to the first example, we create the environment (<code>advanced_cellpose_env</code>) and specify its dependencies.</p> <pre><code>deps = {\"conda\": [\"cellpose==3.1.0\"]}\nenv = environmentManager.create(\"advanced_cellpose_env\", deps)\n</code></pre>"},{"location":"advanced_example/#execute-a-custom-script-in-the-environment","title":"Execute a Custom Script in the Environment","text":"<p>Instead of <code>env.launch()</code>, we use <code>env.executeCommands()</code>. This method allows us to run arbitrary shell commands within the activated environment. Here, we execute a specific Python script (<code>advanced_example_module.py</code>) using <code>python -u</code> (unbuffered output, important for reading stdout line-by-line immediately). We capture the <code>Popen</code> object for the launched process. We also redirect stderr to stdout for easier log capture.</p> <pre><code>print(\"Executing advanced_example_module.py in environment...\")\nprocess = env.executeCommands([\"python -u advanced_example_module.py\"])\n</code></pre>"},{"location":"advanced_example/#establish-manual-connection","title":"Establish Manual Connection","text":"<p>The script we just launched (<code>advanced_example_module.py</code>) is designed to start a server and print the port it's listening on to its standard output. Our main script now needs to read the <code>stdout</code> of the <code>process</code> launched by Cema to discover this port number. We loop through the output lines until we find the line indicating the port.</p> <pre><code>port = None\nif process.stdout is None:\n    print(\"Process has no stdout stream.\", file=sys.stderr)\n    sys.exit(1)\nprint(\"Waiting for environment process to report listening port...\")\nfor line in process.stdout:\n    if line.strip().startswith(\"Listening port \"):\n        port = int(line.strip().replace(\"Listening port \", \"\"))\n        break\n\nprint(f\"Connecting to localhost:{port}...\")\nconnection = Client((\"localhost\", port))\n</code></pre>"},{"location":"advanced_example/#log-environment-output-optional","title":"Log Environment Output (Optional)","text":"<p>To see ongoing output from the script running in the environment, we can start a background thread that continuously reads and prints lines from the process's stdout.</p> <pre><code>def log_output(proc: subprocess.Popen):\n    if proc.stdout:\n        for line_bytes in iter(proc.stdout.readline, b''):\n            print(f\"[Env Output]: {line_bytes.decode().strip()}\")\n\noutput_thread = threading.Thread(target=log_output, args=(process,), daemon=True)\noutput_thread.start()\n</code></pre>"},{"location":"advanced_example/#send-commands-and-receive-results-manually","title":"Send Commands and Receive Results Manually","text":"<p>Now that we have a direct <code>connection</code> object (from <code>multiprocessing.connection.Client</code>), we can implement our own communication protocol. We send dictionaries containing an <code>action</code>, <code>function</code> name, and <code>args</code>. We then wait (<code>connection.recv()</code>) for a response dictionary from the server script running in the environment.</p> <pre><code>imagePath = \"cellpose_img02.png\"\n\nprint(f\"Sending command: download image {imagePath}\")\nconnection.send(dict(action=\"execute\", function=\"downloadImage\", args=[imagePath]))\nresult = connection.recv()\nprint(f\"Received response: {result}\")\n\nsegmentationPath = \"cellpose_img02_segmentation.png\"\nprint(f\"Sending command: segment image {imagePath}\")\nargs = [str(imagePath), str(segmentationPath)]\nconnection.send(dict(action=\"execute\", function=\"segmentImage\", args=args))\nresult = connection.recv()\nprint(f\"Received response: {result}\")\nif 'diameters' in result:\n    print(f\"Object diameters: {result['diameters']}\")\n</code></pre>"},{"location":"advanced_example/#tell-the-environment-process-to-exit-and-clean-up","title":"Tell the Environment Process to Exit and clean up","text":"<p>We send a custom 'exit' message according to our protocol. The server script is designed to shut down upon receiving this message.</p> <pre><code>print(\"Sending exit command...\")\nconnection.send(dict(action=\"exit\"))\n</code></pre> <p>We close our client-side connection and wait for the process we launched with <code>executeCommands</code> to terminate.</p> <pre><code>connection.close()\nprocess.wait(timeout=10)\nif process.returncode is None:\n    process.kill()\n</code></pre> <p>Now, let's examine the <code>advanced_example_module.py</code> script, which is executed by Cema in the isolated environment via <code>executeCommands</code>.</p> <p>Define Callable Functions</p> <p>This script defines the functions (<code>downloadImage</code>, <code>segmentImage</code>) that the main script will invoke remotely. These functions perform the actual work (downloading, segmenting using <code>example_module</code>) inside the environment and use the provided <code>connection</code> object to send back results or status messages.</p> <pre><code># advanced_example_module.py\nimport sys\nimport requests\nfrom multiprocessing.connection import Listener\nfrom pathlib import Path\nimport example_module # Reuse logic from the simple example module\n\ndef downloadImage(imagePath_str, connection):\n    \"\"\"Downloads the image *inside* the environment.\"\"\"\n    imagePath = Path(imagePath_str)\n    print(f\"[Inside Env] Downloading image to {imagePath}...\")\n    try:\n        imageData = requests.get(\"https://www.cellpose.org/static/images/img02.png\").content\n        with open(imagePath, \"wb\") as handler:\n            handler.write(imageData)\n        print(\"[Inside Env] Image downloaded.\")\n        connection.send(dict(status=\"success\", message=\"Image downloaded.\"))\n    except Exception as e:\n        print(f\"[Inside Env] Error downloading image: {e}\")\n        connection.send(dict(status=\"error\", message=str(e)))\n\ndef segmentImage(imagePath_str, segmentationPath_str, connection):\n    \"\"\"Runs segmentation *inside* the environment.\"\"\"\n    imagePath = Path(imagePath_str)\n    segmentationPath = Path(segmentationPath_str)\n    print(f\"[Inside Env] Segmenting {imagePath}...\")\n    try:\n        diameters = example_module.segment(imagePath, segmentationPath)\n        print(\"[Inside Env] Segmentation complete.\")\n        connection.send(dict(status=\"success\", message=\"Image segmented.\", diameters=diameters))\n    except Exception as e:\n        print(f\"[Inside Env] Error during segmentation: {e}\")\n        connection.send(dict(status=\"error\", message=str(e)))\n</code></pre> <p>Set Up the Server</p> <p>The main part of the script uses <code>multiprocessing.connection.Listener</code> to create a server socket listening on <code>localhost</code> and an OS-assigned port (<code>0</code>). Crucially, it prints the chosen port number to standard output, which is how the main script discovers where to connect. It then waits for the main script to connect (<code>listener.accept()</code>).</p> <pre><code>with Listener((\"localhost\", 0)) as listener:\n    # Print the port for the main process to read\n    print(f\"Listening port {listener.address[1]}\", flush=True)\n    with listener.accept() as connection:\n</code></pre> <p>Process Incoming Messages</p> <p>Once connected, the script enters a loop, waiting to receive messages (<code>connection.recv()</code>). It parses the received dictionary, checks the <code>action</code>, and calls the corresponding local function (<code>downloadImage</code> or <code>segmentImage</code>) if the action is <code>execute</code>. If the action is <code>exit</code>, it sends a confirmation and terminates the script (<code>sys.exit(0)</code>).</p> <pre><code>        while message := connection.recv():\n            if message[\"action\"] == \"execute\":\n                locals()[message[\"function\"]](*(message[\"args\"] + [connection]))\n            if message[\"action\"] == \"exit\":\n                connection.send(dict(action=\"Exited.\"))\n                sys.exit(0)\n</code></pre> <p>Summary of Example 2 Flow:</p> <p>The main script uses <code>EnvironmentManager</code> to create an environment. <code>env.executeCommands()</code> starts a custom server script (<code>advanced_example_module.py</code>) inside the environment. The main script reads the server's port from stdout and connects manually using <code>Client</code>. Communication happens via custom message dictionaries sent over this connection. The main script explicitly tells the server to exit before cleaning up the process started by <code>executeCommands</code>. This approach offers more control but requires implementing the server logic and communication protocol.</p>"},{"location":"environment_manager/","title":"Environment manager","text":""},{"location":"environment_manager/#cema.environment_manager.EnvironmentManager","title":"<code>EnvironmentManager</code>","text":"<p>Manages Conda environments using micromamba for isolation and dependency management.</p> <p>Attributes:</p> Name Type Description <code>mainEnvironment</code> <code>InternalEnvironment</code> <p>The main conda environment in which cema is installed.</p> <code>installedPackages</code> <code>dict[str, dict[str, str]]</code> <p>map of the installed packaged (e.g. {\"pip\": {\"numpy\":2.2.4\"}, \"conda\":{\"icu\":\"75.1\"}})</p> <code>environments</code> <code>dict[str, Environment]</code> <p>map of the environments</p> <code>settingsManager</code> <p>SettingsManager(condaPath)</p> <code>dependencyManager</code> <p>DependencyManager(settingsManager)</p> <code>commandGenerator</code> <p>CommandGenerator(settingsManager, dependencyManager)</p> <code>commandExecutor</code> <p>CommandExecutor()</p> Source code in <code>cema/environment_manager.py</code> <pre><code>class EnvironmentManager:\n    \"\"\"Manages Conda environments using micromamba for isolation and dependency management.\n\n    Attributes:\n            mainEnvironment: The main conda environment in which cema is installed.\n            installedPackages: map of the installed packaged (e.g. {\"pip\": {\"numpy\":2.2.4\"}, \"conda\":{\"icu\":\"75.1\"}})\n            environments: map of the environments\n\n            settingsManager: SettingsManager(condaPath)\n            dependencyManager: DependencyManager(settingsManager)\n            commandGenerator: CommandGenerator(settingsManager, dependencyManager)\n            commandExecutor: CommandExecutor()\n    \"\"\"\n\n    mainEnvironment: InternalEnvironment\n    installedPackages: dict[str, dict[str, str]] = {}\n    environments: dict[str, Environment] = {}\n\n    def __init__(\n        self, condaPath: str | Path = Path(\"micromamba\"), mainCondaEnvironmentPath: str | Path | None = None\n    ) -&gt; None:\n        \"\"\"Initializes the EnvironmentManager with a micromamba path.\n\n        Args:\n                condaPath: Path to the micromamba binary. Defaults to \"micromamba\".\n                mainCondaEnvironmentPath: Path of the main conda environment in which cema is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment).\n        \"\"\"\n        self.mainEnvironment = InternalEnvironment(mainCondaEnvironmentPath, self)\n        self.settingsManager = SettingsManager(condaPath)\n        self.dependencyManager = DependencyManager(self.settingsManager)\n        self.commandGenerator = CommandGenerator(self.settingsManager, self.dependencyManager)\n        self.commandExecutor = CommandExecutor()\n\n    def setCondaPath(self, condaPath: str | Path) -&gt; None:\n        \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n        Args:\n                condaPath: New path to micromamba binary.\n\n        Side Effects:\n                Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.\n        \"\"\"\n        self.settingsManager.setCondaPath(condaPath)\n\n    def setProxies(self, proxies: dict[str, str]) -&gt; None:\n        \"\"\"Configures proxy settings for Conda operations.\n\n        Args:\n                proxies: Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).\n\n        Side Effects:\n                Updates .mambarc configuration file with proxy settings.\n        \"\"\"\n        self.settingsManager.setProxies(proxies)\n\n    def _removeChannel(self, condaDependency: str) -&gt; str:\n        \"\"\"Removes channel prefix from a Conda dependency string (e.g., \"channel::package\" -&gt; \"package\").\"\"\"\n        return condaDependency.split(\"::\")[1] if \"::\" in condaDependency else condaDependency\n\n    def _checkRequirement(self, dependency: str, packageManager: Literal[\"pip\", \"conda\"]) -&gt; bool:\n        \"\"\"Check if dependency is installed (exists in self.installedPackages[packageManager])\"\"\"\n        if packageManager == \"conda\":\n            dependency = self._removeChannel(dependency)\n        nameVersion = dependency.split(\"==\")\n        return any(\n            [\n                nameVersion[0] == name and (len(nameVersion) == 1 or version.startswith(nameVersion[1]))\n                for name, version in self.installedPackages[packageManager].items()\n            ]\n        )\n\n    def _dependenciesAreInstalled(self, dependencies: Dependencies) -&gt; bool:\n        \"\"\"Verifies if all specified dependencies are installed in the main environment.\n\n        Args:\n                dependencies: Dependencies to check.\n\n        Returns:\n                True if all dependencies are installed, False otherwise.\n        \"\"\"\n\n        if not sys.version.startswith(dependencies.get(\"python\", \"\").replace(\"=\", \"\")):\n            return False\n\n        condaDependencies, condaDependenciesNoDeps, hasCondaDependencies = self.dependencyManager.formatDependencies(\n            \"conda\", dependencies, False, False\n        )\n        pipDependencies, pipDependenciesNoDeps, hasPipDependencies = self.dependencyManager.formatDependencies(\n            \"pip\", dependencies, False, False\n        )\n\n        if hasCondaDependencies:\n            if self.mainEnvironment.name is None:\n                return False\n            elif \"conda\" not in self.installedPackages:\n                commands = self.commandGenerator.getActivateCondaCommands() + [\n                    f\"{self.settingsManager.condaBin} activate {self.mainEnvironment.name}\",\n                    f\"{self.settingsManager.condaBin} list --json\",\n                ]\n                condaList = self.commandExecutor.executeCommandAndGetOutput(commands, log=False)\n\n                json_output = \"\".join(condaList)\n                conda_list = json.loads(json_output)\n\n                for package_info in conda_list:\n                    name = package_info.get(\"name\")\n                    version = package_info.get(\"version\")\n                    if name and version:\n                        if \"conda\" not in self.installedPackages:\n                            self.installedPackages[\"conda\"] = {}\n                        self.installedPackages[\"conda\"][name] = version\n\n            if not all([self._checkRequirement(d, \"conda\") for d in condaDependencies + condaDependenciesNoDeps]):\n                return False\n        if not hasPipDependencies:\n            return True\n\n        if \"pip\" not in self.installedPackages:\n            if self.mainEnvironment.name is not None:\n                commands = self.commandGenerator.getActivateCondaCommands() + [\n                    f\"{self.settingsManager.condaBin} activate {self.mainEnvironment.name}\",\n                    f\"pip freeze --all\",\n                ]\n                output = self.commandExecutor.executeCommandAndGetOutput(commands, log=False)\n                parsedOutput = [o.split(\"==\") for o in output if \"==\" in o]\n                self.installedPackages[\"pip\"] = {name: version for name, version in parsedOutput}\n            else:\n                self.installedPackages[\"pip\"] = {\n                    dist.metadata[\"Name\"]: dist.version for dist in metadata.distributions()\n                }\n\n        return all([self._checkRequirement(d, \"pip\") for d in pipDependencies + pipDependenciesNoDeps])\n\n    def environmentExists(self, environment: str) -&gt; bool:\n        \"\"\"Checks if a Conda environment exists.\n\n        Args:\n                environment: Environment name to check.\n\n        Returns:\n                True if environment exists, False otherwise.\n        \"\"\"\n        condaMeta = Path(self.settingsManager.condaPath) / \"envs\" / environment / \"conda-meta\"\n        return condaMeta.is_dir()\n\n    def create(\n        self,\n        environment: str,\n        dependencies: Dependencies = {},\n        additionalInstallCommands: Commands = {},\n        forceExternal: bool = False,\n    ) -&gt; Environment:\n        \"\"\"Creates a new Conda environment with specified dependencie or the main environment if dependencies are met in the main environment and forceExternal is False (in which case additional install commands will not be called). Return the existing environment if it was already created.\n\n        Args:\n                environment: Name for the new environment. Ignore if dependencies are already installed in the main environment and forceExternal is False.\n                dependencies: Dependencies to install, in the form dict(python=\"3.12.7\", conda=[\"conda-forge::pyimagej==1.5.0\", dict(name=\"openjdk=11\", platforms=[\"osx-64\", \"osx-arm64\", \"win-64\", \"linux-64\"], dependencies=True, optional=False)], pip=[\"numpy==1.26.4\"]).\n                additionalInstallCommands: Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).\n                forceExternal: force create external environment even if dependencies are met in main environment\n\n        Returns:\n                The created environment (InternalEnvironment if dependencies are met in the main environment and not forceExternal, ExternalEnvironment otherwise).\n        \"\"\"\n        if self.environmentExists(environment):\n            if environment not in self.environments:\n                self.environments[environment] = ExternalEnvironment(environment, self)\n            return self.environments[environment]\n        if not forceExternal and self._dependenciesAreInstalled(dependencies):\n            return self.mainEnvironment\n        pythonVersion = dependencies.get(\"python\", \"\").replace(\"=\", \"\")\n        match = re.search(r\"(\\d+)\\.(\\d+)\", pythonVersion)\n        if match and (int(match.group(1)) &lt; 3 or int(match.group(2)) &lt; 9):\n            raise Exception(\"Python version must be greater than 3.8\")\n        pythonRequirement = \" python=\" + (pythonVersion if len(pythonVersion) &gt; 0 else platform.python_version())\n        createEnvCommands = self.commandGenerator.getActivateCondaCommands()\n        createEnvCommands += [f\"{self.settingsManager.condaBinConfig} create -n {environment}{pythonRequirement} -y\"]\n        createEnvCommands += self.dependencyManager.getInstallDependenciesCommands(environment, dependencies)\n        createEnvCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n        self.commandExecutor.executeCommandAndGetOutput(createEnvCommands)\n        self.environments[environment] = ExternalEnvironment(environment, self)\n        return self.environments[environment]\n\n    def install(\n        self, environmentName: str | None, dependencies: Dependencies, additionalInstallCommands: Commands = {}\n    ) -&gt; list[str]:\n        \"\"\"Installs dependencies.\n        See :meth:`EnvironmentManager.create` for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n        Args:\n                environmentName: The environment to install dependencies.\n                dependencies: Dependencies to install.\n                additionalInstallCommands: Platform-specific commands during installation.\n\n        Returns:\n                Output lines of the installation commands.\n        \"\"\"\n        installCommands = self.commandGenerator.getActivateCondaCommands()\n        installCommands += self.dependencyManager.getInstallDependenciesCommands(environmentName, dependencies)\n        installCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n        return self.commandExecutor.executeCommandAndGetOutput(installCommands)\n\n    def executeCommands(\n        self,\n        environmentName: str | None,\n        commands: Commands,\n        additionalActivateCommands: Commands = {},\n        popenKwargs: dict[str, Any] = {},\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes the given commands in the given environment.\n\n        Args:\n                environmentName: The environment in which to execute commands.\n                commands: The commands to execute in the environment.\n                additionalActivateCommands: Platform-specific activation commands.\n                popenKwargs: Keyword arguments for subprocess.Popen(). See :meth:`CommandExecutor.executeCommands`.\n\n        Returns:\n                The launched process.\n        \"\"\"\n        activateCommands = self.commandGenerator.getActivateEnvironmentCommands(\n            environmentName, additionalActivateCommands\n        )\n        platformCommands = self.commandGenerator.getCommandsForCurrentPlatform(commands)\n        return self.commandExecutor.executeCommands(activateCommands + platformCommands, popenKwargs=popenKwargs)\n\n    def _removeEnvironment(self, environment: Environment) -&gt; None:\n        \"\"\"Remove an environment.\n\n        Args:\n                environment: instance to remove.\n        \"\"\"\n        if environment.name in self.environments:\n            del self.environments[environment.name]\n</code></pre>"},{"location":"environment_manager/#cema.environment_manager.EnvironmentManager.__init__","title":"<code>__init__(condaPath=Path('micromamba'), mainCondaEnvironmentPath=None)</code>","text":"<p>Initializes the EnvironmentManager with a micromamba path.</p> <p>Parameters:</p> Name Type Description Default <code>condaPath</code> <code>str | Path</code> <p>Path to the micromamba binary. Defaults to \"micromamba\".</p> <code>Path('micromamba')</code> <code>mainCondaEnvironmentPath</code> <code>str | Path | None</code> <p>Path of the main conda environment in which cema is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment).</p> <code>None</code> Source code in <code>cema/environment_manager.py</code> <pre><code>def __init__(\n    self, condaPath: str | Path = Path(\"micromamba\"), mainCondaEnvironmentPath: str | Path | None = None\n) -&gt; None:\n    \"\"\"Initializes the EnvironmentManager with a micromamba path.\n\n    Args:\n            condaPath: Path to the micromamba binary. Defaults to \"micromamba\".\n            mainCondaEnvironmentPath: Path of the main conda environment in which cema is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment).\n    \"\"\"\n    self.mainEnvironment = InternalEnvironment(mainCondaEnvironmentPath, self)\n    self.settingsManager = SettingsManager(condaPath)\n    self.dependencyManager = DependencyManager(self.settingsManager)\n    self.commandGenerator = CommandGenerator(self.settingsManager, self.dependencyManager)\n    self.commandExecutor = CommandExecutor()\n</code></pre>"},{"location":"environment_manager/#cema.environment_manager.EnvironmentManager.create","title":"<code>create(environment, dependencies={}, additionalInstallCommands={}, forceExternal=False)</code>","text":"<p>Creates a new Conda environment with specified dependencie or the main environment if dependencies are met in the main environment and forceExternal is False (in which case additional install commands will not be called). Return the existing environment if it was already created.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>str</code> <p>Name for the new environment. Ignore if dependencies are already installed in the main environment and forceExternal is False.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install, in the form dict(python=\"3.12.7\", conda=[\"conda-forge::pyimagej==1.5.0\", dict(name=\"openjdk=11\", platforms=[\"osx-64\", \"osx-arm64\", \"win-64\", \"linux-64\"], dependencies=True, optional=False)], pip=[\"numpy==1.26.4\"]).</p> <code>{}</code> <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).</p> <code>{}</code> <code>forceExternal</code> <code>bool</code> <p>force create external environment even if dependencies are met in main environment</p> <code>False</code> <p>Returns:</p> Type Description <code>Environment</code> <p>The created environment (InternalEnvironment if dependencies are met in the main environment and not forceExternal, ExternalEnvironment otherwise).</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def create(\n    self,\n    environment: str,\n    dependencies: Dependencies = {},\n    additionalInstallCommands: Commands = {},\n    forceExternal: bool = False,\n) -&gt; Environment:\n    \"\"\"Creates a new Conda environment with specified dependencie or the main environment if dependencies are met in the main environment and forceExternal is False (in which case additional install commands will not be called). Return the existing environment if it was already created.\n\n    Args:\n            environment: Name for the new environment. Ignore if dependencies are already installed in the main environment and forceExternal is False.\n            dependencies: Dependencies to install, in the form dict(python=\"3.12.7\", conda=[\"conda-forge::pyimagej==1.5.0\", dict(name=\"openjdk=11\", platforms=[\"osx-64\", \"osx-arm64\", \"win-64\", \"linux-64\"], dependencies=True, optional=False)], pip=[\"numpy==1.26.4\"]).\n            additionalInstallCommands: Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).\n            forceExternal: force create external environment even if dependencies are met in main environment\n\n    Returns:\n            The created environment (InternalEnvironment if dependencies are met in the main environment and not forceExternal, ExternalEnvironment otherwise).\n    \"\"\"\n    if self.environmentExists(environment):\n        if environment not in self.environments:\n            self.environments[environment] = ExternalEnvironment(environment, self)\n        return self.environments[environment]\n    if not forceExternal and self._dependenciesAreInstalled(dependencies):\n        return self.mainEnvironment\n    pythonVersion = dependencies.get(\"python\", \"\").replace(\"=\", \"\")\n    match = re.search(r\"(\\d+)\\.(\\d+)\", pythonVersion)\n    if match and (int(match.group(1)) &lt; 3 or int(match.group(2)) &lt; 9):\n        raise Exception(\"Python version must be greater than 3.8\")\n    pythonRequirement = \" python=\" + (pythonVersion if len(pythonVersion) &gt; 0 else platform.python_version())\n    createEnvCommands = self.commandGenerator.getActivateCondaCommands()\n    createEnvCommands += [f\"{self.settingsManager.condaBinConfig} create -n {environment}{pythonRequirement} -y\"]\n    createEnvCommands += self.dependencyManager.getInstallDependenciesCommands(environment, dependencies)\n    createEnvCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n    self.commandExecutor.executeCommandAndGetOutput(createEnvCommands)\n    self.environments[environment] = ExternalEnvironment(environment, self)\n    return self.environments[environment]\n</code></pre>"},{"location":"environment_manager/#cema.environment_manager.EnvironmentManager.environmentExists","title":"<code>environmentExists(environment)</code>","text":"<p>Checks if a Conda environment exists.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>str</code> <p>Environment name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if environment exists, False otherwise.</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def environmentExists(self, environment: str) -&gt; bool:\n    \"\"\"Checks if a Conda environment exists.\n\n    Args:\n            environment: Environment name to check.\n\n    Returns:\n            True if environment exists, False otherwise.\n    \"\"\"\n    condaMeta = Path(self.settingsManager.condaPath) / \"envs\" / environment / \"conda-meta\"\n    return condaMeta.is_dir()\n</code></pre>"},{"location":"environment_manager/#cema.environment_manager.EnvironmentManager.executeCommands","title":"<code>executeCommands(environmentName, commands, additionalActivateCommands={}, popenKwargs={})</code>","text":"<p>Executes the given commands in the given environment.</p> <p>Parameters:</p> Name Type Description Default <code>environmentName</code> <code>str | None</code> <p>The environment in which to execute commands.</p> required <code>commands</code> <code>Commands</code> <p>The commands to execute in the environment.</p> required <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>popenKwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen(). See :meth:<code>CommandExecutor.executeCommands</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Popen</code> <p>The launched process.</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def executeCommands(\n    self,\n    environmentName: str | None,\n    commands: Commands,\n    additionalActivateCommands: Commands = {},\n    popenKwargs: dict[str, Any] = {},\n) -&gt; subprocess.Popen:\n    \"\"\"Executes the given commands in the given environment.\n\n    Args:\n            environmentName: The environment in which to execute commands.\n            commands: The commands to execute in the environment.\n            additionalActivateCommands: Platform-specific activation commands.\n            popenKwargs: Keyword arguments for subprocess.Popen(). See :meth:`CommandExecutor.executeCommands`.\n\n    Returns:\n            The launched process.\n    \"\"\"\n    activateCommands = self.commandGenerator.getActivateEnvironmentCommands(\n        environmentName, additionalActivateCommands\n    )\n    platformCommands = self.commandGenerator.getCommandsForCurrentPlatform(commands)\n    return self.commandExecutor.executeCommands(activateCommands + platformCommands, popenKwargs=popenKwargs)\n</code></pre>"},{"location":"environment_manager/#cema.environment_manager.EnvironmentManager.install","title":"<code>install(environmentName, dependencies, additionalInstallCommands={})</code>","text":"<p>Installs dependencies. See :meth:<code>EnvironmentManager.create</code> for more details on the <code>dependencies</code> and <code>additionalInstallCommands</code> parameters.</p> <p>Parameters:</p> Name Type Description Default <code>environmentName</code> <code>str | None</code> <p>The environment to install dependencies.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Output lines of the installation commands.</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def install(\n    self, environmentName: str | None, dependencies: Dependencies, additionalInstallCommands: Commands = {}\n) -&gt; list[str]:\n    \"\"\"Installs dependencies.\n    See :meth:`EnvironmentManager.create` for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n    Args:\n            environmentName: The environment to install dependencies.\n            dependencies: Dependencies to install.\n            additionalInstallCommands: Platform-specific commands during installation.\n\n    Returns:\n            Output lines of the installation commands.\n    \"\"\"\n    installCommands = self.commandGenerator.getActivateCondaCommands()\n    installCommands += self.dependencyManager.getInstallDependenciesCommands(environmentName, dependencies)\n    installCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n    return self.commandExecutor.executeCommandAndGetOutput(installCommands)\n</code></pre>"},{"location":"environment_manager/#cema.environment_manager.EnvironmentManager.setCondaPath","title":"<code>setCondaPath(condaPath)</code>","text":"<p>Updates the micromamba path and loads proxy settings if exists.</p> <p>Parameters:</p> Name Type Description Default <code>condaPath</code> <code>str | Path</code> <p>New path to micromamba binary.</p> required Side Effects <p>Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def setCondaPath(self, condaPath: str | Path) -&gt; None:\n    \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n    Args:\n            condaPath: New path to micromamba binary.\n\n    Side Effects:\n            Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.\n    \"\"\"\n    self.settingsManager.setCondaPath(condaPath)\n</code></pre>"},{"location":"environment_manager/#cema.environment_manager.EnvironmentManager.setProxies","title":"<code>setProxies(proxies)</code>","text":"<p>Configures proxy settings for Conda operations.</p> <p>Parameters:</p> Name Type Description Default <code>proxies</code> <code>dict[str, str]</code> <p>Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).</p> required Side Effects <p>Updates .mambarc configuration file with proxy settings.</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def setProxies(self, proxies: dict[str, str]) -&gt; None:\n    \"\"\"Configures proxy settings for Conda operations.\n\n    Args:\n            proxies: Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).\n\n    Side Effects:\n            Updates .mambarc configuration file with proxy settings.\n    \"\"\"\n    self.settingsManager.setProxies(proxies)\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#simplified-execution-with-envimportmodule","title":"Simplified Execution with <code>env.importModule</code>","text":"<p>To demonstrates the most straightforward way to use Cema, we will create an environment, install <code>cellpose</code>, and run a segmentation function defined in a separate file (<code>example_module.py</code>) within that isolated environment.</p> <p>Let's see the main script <code>getting_started.py</code> step by step. </p> <p>We will segment the image <code>img02.png</code> (available here).</p> <pre><code>imagePath = \"img02.png\"\nsegmentationPath = \"img02_segmentation.png\"\n</code></pre>"},{"location":"getting_started/#1-initialize-the-environment-manager","title":"1. Initialize the Environment Manager","text":"<p>We start by initializing the <code>EnvironmentManager</code>. We provide a path (<code>\"micromamba/\"</code>) where Cema should look for an existing Micromamba installation or where it should download and set up a new one if it's not found.</p> <pre><code>from cema.environment_manager import EnvironmentManager\nimport requests\nfrom pathlib import Path\n\nenvironmentManager = EnvironmentManager(\"micromamba/\")\n</code></pre> <p>Note</p> <p>EnvironmentManager also accepts a <code>mainCondaEnvironmentPath</code> argument, useful if Cema is used in a conda environment (e.g. <code>environmentManager = EnvironmentManager(\"micromamba/\", \"/path/to/project/environment/\")</code>). Cema will activate this main environment and check if the installed packages satisfy the requirements when creating new environments. If the required dependencies are already installed in the main environment, EnvironmentManager.create() will return the main enviroment instead of creating a new one. The modules will be called directly, bypassing the Cema communication server.</p>"},{"location":"getting_started/#2-create-or-get-an-environment-and-install-dependencies","title":"2. Create (or get) an Environment and Install Dependencies","text":"<p>Next, we define and create the Conda environment. We give it a name (<code>\"cellpose_env\"</code>) and specify its dependencies using a dictionary. Here, we require <code>cellpose</code> version 3.1.0, to be installed via Conda. If an environment with this name already exists, Cema will use it (and ignore the dependencies); otherwise, it will create it and install the specified dependencies. The <code>create</code> method returns an <code>Environment</code> object.</p> <pre><code>env = environmentManager.create(\n    \"cellpose_env\",\n    {\"conda\": [\"cellpose==3.1.0\"]}\n)\n</code></pre> <p>Note</p> <p>If a <code>mainCondaEnvironmentPath</code> was provided when instanciating the <code>EnvironmentManager</code>, Cema will check if <code>cellpose==3.1.0</code> is already installed in the main environment and return it if it is the case. If <code>mainCondaEnvironmentPath</code> is not provided but the required dependencies are only pip packages, Cema will check if the dependencies are installed in the current python environment and return it if it is the case.</p>"},{"location":"getting_started/#3-launch-the-environments-communication-server","title":"3. Launch the Environment's Communication Server","text":"<p>For Cema to execute code within the isolated environment (using <code>importModule</code> or <code>execute</code>), we need to launch its background communication server. This server runs as a separate process inside the <code>cellpose_env</code> and listens for commands from our main script.</p> <pre><code>env.launch()\n</code></pre>"},{"location":"getting_started/#4-import-and-execute-code-in-the-environment-via-proxy","title":"4. Import and Execute Code in the Environment via Proxy","text":"<p>This is where the core Cema interaction happens. We use <code>env.importModule(\"example_module.py\")</code> to gain access to the functions defined in <code>example_module.py</code>. Cema doesn't actually import the module into the main process; instead, it returns a proxy object. When we call a method on this proxy object (like <code>example_module.segment(...)</code>), Cema intercepts the call, sends the function name and arguments to the server running in the <code>cellpose_env</code>, executes the real function there, and returns the result back to the main script. File paths and other pickleable arguments are automatically transferred.</p> <pre><code>print(\"Importing module in environment...\")\nexample_module = env.importModule(\"example_module.py\")\n\nprint(f\"Running segmentation on {imagePath}...\")\ndiameters = example_module.segment(imagePath, segmentationPath)\n\nprint(f\"Segmentation complete. Found diameters of {diameters} pixels.\")\n</code></pre> <p>Alternatively, we could use <code>env.execute()</code> directly:</p> <pre><code>print(f\"Running segmentation on {imagePath}...\")\nargs = (imagePath, segmentationPath)\ndiameters = env.execute(\"example_module.py\", \"segment\", args)\n\nprint(f\"Segmentation complete. Found diameters of {diameters} pixels.\")\n</code></pre>"},{"location":"getting_started/#5-clean-up","title":"5. Clean Up","text":"<p>Finally, we tell Cema to shut down the communication server and clean up resources associated with the launched environment.</p> <pre><code>print(\"Exiting environment...\")\nenv.exit()\n\nprint(\"Done.\")\n</code></pre> <code>getting_started.py</code> source code <pre><code>from cema.environment_manager import EnvironmentManager\nimport requests\n\n# Declare our input and output paths\nimagePath = \"img02.png\"\nsegmentationPath = \"img02_segmentation.png\"\n\n# Initialize the environment manager\n# Cema will use the existing Micromamba installation at the specified path (e.g., \"micromamba/\") if available;\n# otherwise it will automatically download and install Micromamba in a self-contained manner.\nenvironmentManager = EnvironmentManager(\"micromamba/\")\n\n# Create and launch an isolated Conda environment named \"cellpose\"\nenv = environmentManager.create(\"cellpose\", {\"conda\": [\"cellpose==3.1.0\"]})\nenv.launch()\n\n# Import example_module in the environment\nexample_module = env.importModule(\"example_module.py\")\n# example_module is a proxy to example_module.py in the environment,\n# calling example_module.function_name(args) will run env.execute(module_name, function_name, args)\ndiameters = example_module.segment(imagePath, segmentationPath)\n\n# Or use env.execute() directly\n# diameters = env.execute(\"example_module.py\", \"segment\", (imagePath, segmentationPath))\n\nprint(f\"Found diameters of {diameters} pixels.\")\n\n# Clean up and exit the environment\nenv.exit()\n</code></pre> <p>Now, let's look at the <code>example_module.py</code> file. This code contains the actual segmentation logic and is executed inside the isolated <code>cellpose_env</code> when called via the proxy object.</p>"},{"location":"getting_started/#define-the-segmentation-function","title":"Define the Segmentation Function","text":"<p>The module defines a <code>segment</code> function that takes input/output paths and other parameters. It uses a global variable <code>model</code> to potentially cache the loaded Cellpose model between calls within the same environment process lifetime.</p> <pre><code># example_module.py\nfrom pathlib import Path\nfrom typing import Any, cast\n\nmodel = None\n\ndef segment(\n    input_image: Path | str,\n    segmentation: Path | str,\n    model_type=\"cyto\",\n    use_gpu=False,\n    channels=[0, 0],\n    auto_diameter=True,\n    diameter=30,\n):\n    \"\"\"Performs cell segmentation using Cellpose.\"\"\"\n    global model\n\n    input_image = Path(input_image)\n    if not input_image.exists():\n        raise FileNotFoundError(f\"Error: input image {input_image}\"\\\n                                \"does not exist.\")\n</code></pre>"},{"location":"getting_started/#import-dependencies-inside-the-environment","title":"Import Dependencies (Inside the Environment)","text":"<p>Crucially, the necessary libraries (<code>cellpose</code>, <code>numpy</code>) are imported within this function, meaning they are resolved using the packages installed inside the isolated <code>cellpose_env</code>, not the main script's environment. This is important to enable the main script to import <code>example_module.py</code> without raising a <code>ModuleNotFoundError</code>. In this way, the main script can see the functions defined in <code>example_module.py</code>. This is only necessary when using the proxy object (<code>env.importModule(\"example_module.py\")</code> then <code>example_module.function(args)</code>) but it is not required when using <code>env.execute(\"example_module.py\", \"function\", (args))</code> directly.</p> <pre><code>    print(f\"[[1/4]] Load libraries and model '{model_type}'\")\n    import cellpose.models\n    import cellpose.io\n    import numpy as np\n</code></pre> <p>Using try catch to prevent <code>ModuleNotFoundError</code></p> <p>A better approach is to use a try statement at the beginning of <code>example_module.py</code> to fail silently when importing modules which are not accessible in the main environment, like so:</p> <pre><code>try:\n    import cellpose.models\n    import cellpose.io\n    import numpy as np\nexcept ModuleNotFoundError:\n    pass\n...\n</code></pre> <p>This allows:  - to access the function definitions in the main environment (even if we won't be able to execute them in the main environment),  - to import the modules for all functions defined in <code>example_module.py</code> in the <code>cellpose_env</code>.</p>"},{"location":"getting_started/#load-model-and-process-image","title":"Load Model and Process Image","text":"<p>The code proceeds to load the Cellpose model (if not already cached) and the input image. All this happens within the context of the <code>cellpose_env</code>.</p> <pre><code>    if model is None or model.cp.model_type != model_type:\n        print(\"Loading model...\")\n        gpu_flag = str(use_gpu).lower() == 'true'\n        model = cellpose.models.Cellpose(gpu=gpu_flag, model_type=model_type)\n\n    print(f\"[[2/4]] Load image {input_image}\")\n    image = cast(np.ndarray, cellpose.io.imread(str(input_image)))\n</code></pre>"},{"location":"getting_started/#perform-segmentation","title":"Perform Segmentation","text":"<p>The core segmentation task is performed using the loaded model and image. Any exceptions raised here will be captured by Cema and re-raised in the main script.</p> <pre><code>    print(f\"[[3/4]] Compute segmentation for image shape {image.shape}\")\n    try:\n        kwargs: Any = dict(diameter=int(diameter)) if auto_diameter else {}\n        masks, _, _, diams = model.eval(image, channels=channels, **kwargs)\n    except Exception as e:\n        print(f\"Error during segmentation: {e}\")\n        raise e\n    print(\"Segmentation finished (inside environment).\")\n</code></pre>"},{"location":"getting_started/#save-results-and-return-value","title":"Save Results and Return Value","text":"<p>The segmentation results (masks) are saved to disk, potentially renaming the output file. The function then returns the calculated cell diameters (<code>diams</code>). This return value is serialized by Cema and sent back to the main script.</p> <pre><code>    segmentation_path = Path(segmentation)\n    print(f\"[[4/4]] Save segmentation to {segmentation_path}\")\n\n    cellpose.io.save_masks(image, masks, flows, str(input_image), png=True)\n    default_output = input_image.parent / f\"{input_image.stem}_cp_masks.png\"\n\n    if default_output.exists():\n        if segmentation_path.exists():\n            segmentation_path.unlink()\n        default_output.rename(segmentation_path)\n        print(f\"Saved mask: {segmentation_path}\")\n    else:\n        print(\"Warning: Segmentation mask file was not generated by cellpose.\")\n\n    return diams\n</code></pre> <code>example_module.py</code> source code <pre><code>from pathlib import Path\nfrom typing import Any, cast\n\nmodel = None\n\n\ndef segment(\n    input_image: Path | str,\n    segmentation: Path | str,\n    model_type=\"cyto\",\n    use_gpu=False,\n    channels=[0, 0],\n    auto_diameter=True,\n    diameter=30,\n):\n    global model\n\n    input_image = Path(input_image)\n    if not input_image.exists():\n        raise Exception(f\"Error: input image {input_image} does not exist.\")\n\n    print(f\"[[1/4]] Load libraries and model {model_type}\")\n    print(\"Loading libraries...\")\n    import cellpose.models  # type: ignore\n    import cellpose.io  # type: ignore\n    import numpy as np  # type: ignore\n\n    if model is None or model.cp.model_type != model_type:\n        print(\"Loading model...\")\n        model = cellpose.models.Cellpose(gpu=True if use_gpu == \"True\" else False, model_type=model_type)\n\n    print(f\"[[2/4]] Load image {input_image}\")\n    image = cast(np.ndarray, cellpose.io.imread(str(input_image)))\n\n    print(\"[[3/4]] Compute segmentation\", image.shape)\n    try:\n        kwargs: Any = dict(diameter=int(diameter)) if auto_diameter else {}\n        masks, flows, styles, diams = model.eval(image, channels=channels, **kwargs)\n    except Exception as e:\n        print(e)\n        raise e\n    print(\"segmentation finished.\")\n\n    segmentation = Path(segmentation)\n    print(f\"[[4/4]] Save segmentation {segmentation}\")\n    # save results as png\n    cellpose.io.save_masks(image, masks, flows, str(input_image), png=True)\n    output_mask = input_image.parent / f\"{input_image.stem}_cp_masks.png\"\n    if output_mask.exists():\n        if segmentation.exists():\n            segmentation.unlink()\n        (output_mask).rename(segmentation)\n        print(f\"Saved out: {segmentation}\")\n    else:\n        print(\"Segmentation was not generated because no masks were found.\")\n    return diams\n</code></pre>"},{"location":"getting_started/#summary-of-example-1-flow","title":"Summary of Example 1 Flow:","text":"<p>The main script uses <code>EnvironmentManager</code> to prepare an isolated environment. <code>env.launch()</code> starts a hidden server in that environment. <code>env.importModule()</code> provides a proxy, and calling functions on the proxy executes the code (like <code>example_module.segment</code>) within the isolated environment, handling data transfer automatically. <code>env.exit()</code> cleans up the server process.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Environment</li> <li>Environment manager</li> <li>External environment</li> <li>Internal environment</li> </ul>"},{"location":"reference/cema/environment/","title":"Environment","text":""},{"location":"reference/cema/environment/#cema.environment.Environment","title":"<code>Environment</code>","text":"Source code in <code>cema/environment.py</code> <pre><code>class Environment:\n    modules: dict[str, ModuleType] = {}\n\n    def __init__(self, name: str | None, environmentManager: \"EnvironmentManager\") -&gt; None:\n        self.name = name\n        self.environmentManager = environmentManager\n\n    def _isModFunction(self, mod, func):\n        \"\"\"Checks that func is a function defined in module mod\"\"\"\n        return inspect.isfunction(func) and inspect.getmodule(func) == mod\n\n    def _listFunctions(self, mod):\n        \"\"\"Returns the list of functions defined in module mod\"\"\"\n        return [func.__name__ for func in mod.__dict__.values() if self._isModFunction(mod, func)]\n\n    def _importModule(self, modulePath: Path | str):\n        \"\"\"Imports the given module (if necessary) and adds it to the module map.\"\"\"\n        modulePath = Path(modulePath)\n        module = modulePath.stem\n        if module not in self.modules:\n            sys.path.append(str(modulePath.parent))\n            self.modules[module] = import_module(module)\n        return self.modules[module]\n\n    def importModule(self, modulePath: Path | str) -&gt; Any:\n        \"\"\"Imports the given module (if necessary) and returns a fake module object\n        that contains the same methods of the module which will be executed within the environment.\"\"\"\n        module = self._importModule(modulePath)\n\n        class FakeModule:\n            pass\n\n        for f in self._listFunctions(module):\n\n            def fakeFunction(*args, _cema_imported_function=f, **kwargs):\n                return self.execute(modulePath, _cema_imported_function, args, kwargs)\n\n            setattr(FakeModule, f, fakeFunction)\n        return FakeModule\n\n    def install(self, dependencies: Dependencies, additionalInstallCommands: Commands = {}) -&gt; list[str]:\n        \"\"\"Installs dependencies.\n        See :meth:`EnvironmentManager.create` for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n        Args:\n                dependencies: Dependencies to install.\n                additionalInstallCommands: Platform-specific commands during installation.\n        Returns:\n                Output lines of the installation commands.\n        \"\"\"\n        return self.environmentManager.install(self.name, dependencies, additionalInstallCommands)\n\n    @abstractmethod\n    def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n        \"\"\"See :meth:`InternalEnvironment.launch` and :meth:`ExternalEnvironment.launch`\"\"\"\n        pass\n\n    def executeCommands(\n        self, commands: Commands, additionalActivateCommands: Commands = {}, popenKwargs: dict[str, Any] = {}\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes the given commands in this environment.\n\n        Args:\n                commands: The commands to execute in the environment.\n                additionalActivateCommands: Platform-specific activation commands.\n                popenKwargs: Keyword arguments for subprocess.Popen(). See :meth:`CommandExecutor.executeCommands`.\n\n        Returns:\n                The launched process.\n        \"\"\"\n        return self.environmentManager.executeCommands(self.name, commands, additionalActivateCommands, popenKwargs)\n\n    @abstractmethod\n    def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Execute the given function in the given module. See :meth:`ExternalEnvironment.execute` and :meth:`InternalEnvironment.execute`\"\"\"\n        pass\n\n    def _exit(self) -&gt; None:\n        \"\"\"Exit the environment, important in ExternalEnvironment\"\"\"\n        pass\n\n    def launched(self) -&gt; bool:\n        \"\"\"Check if the environment is launched, important in ExternalEnvironment\"\"\"\n        return True\n\n    def exit(self) -&gt; None:\n        \"\"\"Exit the environment\"\"\"\n        self._exit()\n        self.environmentManager._removeEnvironment(self)\n</code></pre>"},{"location":"reference/cema/environment/#cema.environment.Environment.execute","title":"<code>execute(modulePath, function, args=(), kwargs={})</code>  <code>abstractmethod</code>","text":"<p>Execute the given function in the given module. See :meth:<code>ExternalEnvironment.execute</code> and :meth:<code>InternalEnvironment.execute</code></p> Source code in <code>cema/environment.py</code> <pre><code>@abstractmethod\ndef execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Execute the given function in the given module. See :meth:`ExternalEnvironment.execute` and :meth:`InternalEnvironment.execute`\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cema/environment/#cema.environment.Environment.executeCommands","title":"<code>executeCommands(commands, additionalActivateCommands={}, popenKwargs={})</code>","text":"<p>Executes the given commands in this environment.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>Commands</code> <p>The commands to execute in the environment.</p> required <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>popenKwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen(). See :meth:<code>CommandExecutor.executeCommands</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Popen</code> <p>The launched process.</p> Source code in <code>cema/environment.py</code> <pre><code>def executeCommands(\n    self, commands: Commands, additionalActivateCommands: Commands = {}, popenKwargs: dict[str, Any] = {}\n) -&gt; subprocess.Popen:\n    \"\"\"Executes the given commands in this environment.\n\n    Args:\n            commands: The commands to execute in the environment.\n            additionalActivateCommands: Platform-specific activation commands.\n            popenKwargs: Keyword arguments for subprocess.Popen(). See :meth:`CommandExecutor.executeCommands`.\n\n    Returns:\n            The launched process.\n    \"\"\"\n    return self.environmentManager.executeCommands(self.name, commands, additionalActivateCommands, popenKwargs)\n</code></pre>"},{"location":"reference/cema/environment/#cema.environment.Environment.exit","title":"<code>exit()</code>","text":"<p>Exit the environment</p> Source code in <code>cema/environment.py</code> <pre><code>def exit(self) -&gt; None:\n    \"\"\"Exit the environment\"\"\"\n    self._exit()\n    self.environmentManager._removeEnvironment(self)\n</code></pre>"},{"location":"reference/cema/environment/#cema.environment.Environment.importModule","title":"<code>importModule(modulePath)</code>","text":"<p>Imports the given module (if necessary) and returns a fake module object that contains the same methods of the module which will be executed within the environment.</p> Source code in <code>cema/environment.py</code> <pre><code>def importModule(self, modulePath: Path | str) -&gt; Any:\n    \"\"\"Imports the given module (if necessary) and returns a fake module object\n    that contains the same methods of the module which will be executed within the environment.\"\"\"\n    module = self._importModule(modulePath)\n\n    class FakeModule:\n        pass\n\n    for f in self._listFunctions(module):\n\n        def fakeFunction(*args, _cema_imported_function=f, **kwargs):\n            return self.execute(modulePath, _cema_imported_function, args, kwargs)\n\n        setattr(FakeModule, f, fakeFunction)\n    return FakeModule\n</code></pre>"},{"location":"reference/cema/environment/#cema.environment.Environment.install","title":"<code>install(dependencies, additionalInstallCommands={})</code>","text":"<p>Installs dependencies. See :meth:<code>EnvironmentManager.create</code> for more details on the <code>dependencies</code> and <code>additionalInstallCommands</code> parameters.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <p>Returns:         Output lines of the installation commands.</p> Source code in <code>cema/environment.py</code> <pre><code>def install(self, dependencies: Dependencies, additionalInstallCommands: Commands = {}) -&gt; list[str]:\n    \"\"\"Installs dependencies.\n    See :meth:`EnvironmentManager.create` for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n    Args:\n            dependencies: Dependencies to install.\n            additionalInstallCommands: Platform-specific commands during installation.\n    Returns:\n            Output lines of the installation commands.\n    \"\"\"\n    return self.environmentManager.install(self.name, dependencies, additionalInstallCommands)\n</code></pre>"},{"location":"reference/cema/environment/#cema.environment.Environment.launch","title":"<code>launch(additionalActivateCommands={}, logOutputInThread=True)</code>  <code>abstractmethod</code>","text":"<p>See :meth:<code>InternalEnvironment.launch</code> and :meth:<code>ExternalEnvironment.launch</code></p> Source code in <code>cema/environment.py</code> <pre><code>@abstractmethod\ndef launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n    \"\"\"See :meth:`InternalEnvironment.launch` and :meth:`ExternalEnvironment.launch`\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cema/environment/#cema.environment.Environment.launched","title":"<code>launched()</code>","text":"<p>Check if the environment is launched, important in ExternalEnvironment</p> Source code in <code>cema/environment.py</code> <pre><code>def launched(self) -&gt; bool:\n    \"\"\"Check if the environment is launched, important in ExternalEnvironment\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cema/environment_manager/","title":"Environment manager","text":""},{"location":"reference/cema/environment_manager/#cema.environment_manager.EnvironmentManager","title":"<code>EnvironmentManager</code>","text":"<p>Manages Conda environments using micromamba for isolation and dependency management.</p> <p>Attributes:</p> Name Type Description <code>mainEnvironment</code> <code>InternalEnvironment</code> <p>The main conda environment in which cema is installed.</p> <code>installedPackages</code> <code>dict[str, dict[str, str]]</code> <p>map of the installed packaged (e.g. {\"pip\": {\"numpy\":2.2.4\"}, \"conda\":{\"icu\":\"75.1\"}})</p> <code>environments</code> <code>dict[str, Environment]</code> <p>map of the environments</p> <code>settingsManager</code> <p>SettingsManager(condaPath)</p> <code>dependencyManager</code> <p>DependencyManager(settingsManager)</p> <code>commandGenerator</code> <p>CommandGenerator(settingsManager, dependencyManager)</p> <code>commandExecutor</code> <p>CommandExecutor()</p> Source code in <code>cema/environment_manager.py</code> <pre><code>class EnvironmentManager:\n    \"\"\"Manages Conda environments using micromamba for isolation and dependency management.\n\n    Attributes:\n            mainEnvironment: The main conda environment in which cema is installed.\n            installedPackages: map of the installed packaged (e.g. {\"pip\": {\"numpy\":2.2.4\"}, \"conda\":{\"icu\":\"75.1\"}})\n            environments: map of the environments\n\n            settingsManager: SettingsManager(condaPath)\n            dependencyManager: DependencyManager(settingsManager)\n            commandGenerator: CommandGenerator(settingsManager, dependencyManager)\n            commandExecutor: CommandExecutor()\n    \"\"\"\n\n    mainEnvironment: InternalEnvironment\n    installedPackages: dict[str, dict[str, str]] = {}\n    environments: dict[str, Environment] = {}\n\n    def __init__(\n        self, condaPath: str | Path = Path(\"micromamba\"), mainCondaEnvironmentPath: str | Path | None = None\n    ) -&gt; None:\n        \"\"\"Initializes the EnvironmentManager with a micromamba path.\n\n        Args:\n                condaPath: Path to the micromamba binary. Defaults to \"micromamba\".\n                mainCondaEnvironmentPath: Path of the main conda environment in which cema is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment).\n        \"\"\"\n        self.mainEnvironment = InternalEnvironment(mainCondaEnvironmentPath, self)\n        self.settingsManager = SettingsManager(condaPath)\n        self.dependencyManager = DependencyManager(self.settingsManager)\n        self.commandGenerator = CommandGenerator(self.settingsManager, self.dependencyManager)\n        self.commandExecutor = CommandExecutor()\n\n    def setCondaPath(self, condaPath: str | Path) -&gt; None:\n        \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n        Args:\n                condaPath: New path to micromamba binary.\n\n        Side Effects:\n                Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.\n        \"\"\"\n        self.settingsManager.setCondaPath(condaPath)\n\n    def setProxies(self, proxies: dict[str, str]) -&gt; None:\n        \"\"\"Configures proxy settings for Conda operations.\n\n        Args:\n                proxies: Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).\n\n        Side Effects:\n                Updates .mambarc configuration file with proxy settings.\n        \"\"\"\n        self.settingsManager.setProxies(proxies)\n\n    def _removeChannel(self, condaDependency: str) -&gt; str:\n        \"\"\"Removes channel prefix from a Conda dependency string (e.g., \"channel::package\" -&gt; \"package\").\"\"\"\n        return condaDependency.split(\"::\")[1] if \"::\" in condaDependency else condaDependency\n\n    def _checkRequirement(self, dependency: str, packageManager: Literal[\"pip\", \"conda\"]) -&gt; bool:\n        \"\"\"Check if dependency is installed (exists in self.installedPackages[packageManager])\"\"\"\n        if packageManager == \"conda\":\n            dependency = self._removeChannel(dependency)\n        nameVersion = dependency.split(\"==\")\n        return any(\n            [\n                nameVersion[0] == name and (len(nameVersion) == 1 or version.startswith(nameVersion[1]))\n                for name, version in self.installedPackages[packageManager].items()\n            ]\n        )\n\n    def _dependenciesAreInstalled(self, dependencies: Dependencies) -&gt; bool:\n        \"\"\"Verifies if all specified dependencies are installed in the main environment.\n\n        Args:\n                dependencies: Dependencies to check.\n\n        Returns:\n                True if all dependencies are installed, False otherwise.\n        \"\"\"\n\n        if not sys.version.startswith(dependencies.get(\"python\", \"\").replace(\"=\", \"\")):\n            return False\n\n        condaDependencies, condaDependenciesNoDeps, hasCondaDependencies = self.dependencyManager.formatDependencies(\n            \"conda\", dependencies, False, False\n        )\n        pipDependencies, pipDependenciesNoDeps, hasPipDependencies = self.dependencyManager.formatDependencies(\n            \"pip\", dependencies, False, False\n        )\n\n        if hasCondaDependencies:\n            if self.mainEnvironment.name is None:\n                return False\n            elif \"conda\" not in self.installedPackages:\n                commands = self.commandGenerator.getActivateCondaCommands() + [\n                    f\"{self.settingsManager.condaBin} activate {self.mainEnvironment.name}\",\n                    f\"{self.settingsManager.condaBin} list --json\",\n                ]\n                condaList = self.commandExecutor.executeCommandAndGetOutput(commands, log=False)\n\n                json_output = \"\".join(condaList)\n                conda_list = json.loads(json_output)\n\n                for package_info in conda_list:\n                    name = package_info.get(\"name\")\n                    version = package_info.get(\"version\")\n                    if name and version:\n                        if \"conda\" not in self.installedPackages:\n                            self.installedPackages[\"conda\"] = {}\n                        self.installedPackages[\"conda\"][name] = version\n\n            if not all([self._checkRequirement(d, \"conda\") for d in condaDependencies + condaDependenciesNoDeps]):\n                return False\n        if not hasPipDependencies:\n            return True\n\n        if \"pip\" not in self.installedPackages:\n            if self.mainEnvironment.name is not None:\n                commands = self.commandGenerator.getActivateCondaCommands() + [\n                    f\"{self.settingsManager.condaBin} activate {self.mainEnvironment.name}\",\n                    f\"pip freeze --all\",\n                ]\n                output = self.commandExecutor.executeCommandAndGetOutput(commands, log=False)\n                parsedOutput = [o.split(\"==\") for o in output if \"==\" in o]\n                self.installedPackages[\"pip\"] = {name: version for name, version in parsedOutput}\n            else:\n                self.installedPackages[\"pip\"] = {\n                    dist.metadata[\"Name\"]: dist.version for dist in metadata.distributions()\n                }\n\n        return all([self._checkRequirement(d, \"pip\") for d in pipDependencies + pipDependenciesNoDeps])\n\n    def environmentExists(self, environment: str) -&gt; bool:\n        \"\"\"Checks if a Conda environment exists.\n\n        Args:\n                environment: Environment name to check.\n\n        Returns:\n                True if environment exists, False otherwise.\n        \"\"\"\n        condaMeta = Path(self.settingsManager.condaPath) / \"envs\" / environment / \"conda-meta\"\n        return condaMeta.is_dir()\n\n    def create(\n        self,\n        environment: str,\n        dependencies: Dependencies = {},\n        additionalInstallCommands: Commands = {},\n        forceExternal: bool = False,\n    ) -&gt; Environment:\n        \"\"\"Creates a new Conda environment with specified dependencie or the main environment if dependencies are met in the main environment and forceExternal is False (in which case additional install commands will not be called). Return the existing environment if it was already created.\n\n        Args:\n                environment: Name for the new environment. Ignore if dependencies are already installed in the main environment and forceExternal is False.\n                dependencies: Dependencies to install, in the form dict(python=\"3.12.7\", conda=[\"conda-forge::pyimagej==1.5.0\", dict(name=\"openjdk=11\", platforms=[\"osx-64\", \"osx-arm64\", \"win-64\", \"linux-64\"], dependencies=True, optional=False)], pip=[\"numpy==1.26.4\"]).\n                additionalInstallCommands: Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).\n                forceExternal: force create external environment even if dependencies are met in main environment\n\n        Returns:\n                The created environment (InternalEnvironment if dependencies are met in the main environment and not forceExternal, ExternalEnvironment otherwise).\n        \"\"\"\n        if self.environmentExists(environment):\n            if environment not in self.environments:\n                self.environments[environment] = ExternalEnvironment(environment, self)\n            return self.environments[environment]\n        if not forceExternal and self._dependenciesAreInstalled(dependencies):\n            return self.mainEnvironment\n        pythonVersion = dependencies.get(\"python\", \"\").replace(\"=\", \"\")\n        match = re.search(r\"(\\d+)\\.(\\d+)\", pythonVersion)\n        if match and (int(match.group(1)) &lt; 3 or int(match.group(2)) &lt; 9):\n            raise Exception(\"Python version must be greater than 3.8\")\n        pythonRequirement = \" python=\" + (pythonVersion if len(pythonVersion) &gt; 0 else platform.python_version())\n        createEnvCommands = self.commandGenerator.getActivateCondaCommands()\n        createEnvCommands += [f\"{self.settingsManager.condaBinConfig} create -n {environment}{pythonRequirement} -y\"]\n        createEnvCommands += self.dependencyManager.getInstallDependenciesCommands(environment, dependencies)\n        createEnvCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n        self.commandExecutor.executeCommandAndGetOutput(createEnvCommands)\n        self.environments[environment] = ExternalEnvironment(environment, self)\n        return self.environments[environment]\n\n    def install(\n        self, environmentName: str | None, dependencies: Dependencies, additionalInstallCommands: Commands = {}\n    ) -&gt; list[str]:\n        \"\"\"Installs dependencies.\n        See :meth:`EnvironmentManager.create` for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n        Args:\n                environmentName: The environment to install dependencies.\n                dependencies: Dependencies to install.\n                additionalInstallCommands: Platform-specific commands during installation.\n\n        Returns:\n                Output lines of the installation commands.\n        \"\"\"\n        installCommands = self.commandGenerator.getActivateCondaCommands()\n        installCommands += self.dependencyManager.getInstallDependenciesCommands(environmentName, dependencies)\n        installCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n        return self.commandExecutor.executeCommandAndGetOutput(installCommands)\n\n    def executeCommands(\n        self,\n        environmentName: str | None,\n        commands: Commands,\n        additionalActivateCommands: Commands = {},\n        popenKwargs: dict[str, Any] = {},\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes the given commands in the given environment.\n\n        Args:\n                environmentName: The environment in which to execute commands.\n                commands: The commands to execute in the environment.\n                additionalActivateCommands: Platform-specific activation commands.\n                popenKwargs: Keyword arguments for subprocess.Popen(). See :meth:`CommandExecutor.executeCommands`.\n\n        Returns:\n                The launched process.\n        \"\"\"\n        activateCommands = self.commandGenerator.getActivateEnvironmentCommands(\n            environmentName, additionalActivateCommands\n        )\n        platformCommands = self.commandGenerator.getCommandsForCurrentPlatform(commands)\n        return self.commandExecutor.executeCommands(activateCommands + platformCommands, popenKwargs=popenKwargs)\n\n    def _removeEnvironment(self, environment: Environment) -&gt; None:\n        \"\"\"Remove an environment.\n\n        Args:\n                environment: instance to remove.\n        \"\"\"\n        if environment.name in self.environments:\n            del self.environments[environment.name]\n</code></pre>"},{"location":"reference/cema/environment_manager/#cema.environment_manager.EnvironmentManager.__init__","title":"<code>__init__(condaPath=Path('micromamba'), mainCondaEnvironmentPath=None)</code>","text":"<p>Initializes the EnvironmentManager with a micromamba path.</p> <p>Parameters:</p> Name Type Description Default <code>condaPath</code> <code>str | Path</code> <p>Path to the micromamba binary. Defaults to \"micromamba\".</p> <code>Path('micromamba')</code> <code>mainCondaEnvironmentPath</code> <code>str | Path | None</code> <p>Path of the main conda environment in which cema is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment).</p> <code>None</code> Source code in <code>cema/environment_manager.py</code> <pre><code>def __init__(\n    self, condaPath: str | Path = Path(\"micromamba\"), mainCondaEnvironmentPath: str | Path | None = None\n) -&gt; None:\n    \"\"\"Initializes the EnvironmentManager with a micromamba path.\n\n    Args:\n            condaPath: Path to the micromamba binary. Defaults to \"micromamba\".\n            mainCondaEnvironmentPath: Path of the main conda environment in which cema is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment).\n    \"\"\"\n    self.mainEnvironment = InternalEnvironment(mainCondaEnvironmentPath, self)\n    self.settingsManager = SettingsManager(condaPath)\n    self.dependencyManager = DependencyManager(self.settingsManager)\n    self.commandGenerator = CommandGenerator(self.settingsManager, self.dependencyManager)\n    self.commandExecutor = CommandExecutor()\n</code></pre>"},{"location":"reference/cema/environment_manager/#cema.environment_manager.EnvironmentManager.create","title":"<code>create(environment, dependencies={}, additionalInstallCommands={}, forceExternal=False)</code>","text":"<p>Creates a new Conda environment with specified dependencie or the main environment if dependencies are met in the main environment and forceExternal is False (in which case additional install commands will not be called). Return the existing environment if it was already created.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>str</code> <p>Name for the new environment. Ignore if dependencies are already installed in the main environment and forceExternal is False.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install, in the form dict(python=\"3.12.7\", conda=[\"conda-forge::pyimagej==1.5.0\", dict(name=\"openjdk=11\", platforms=[\"osx-64\", \"osx-arm64\", \"win-64\", \"linux-64\"], dependencies=True, optional=False)], pip=[\"numpy==1.26.4\"]).</p> <code>{}</code> <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).</p> <code>{}</code> <code>forceExternal</code> <code>bool</code> <p>force create external environment even if dependencies are met in main environment</p> <code>False</code> <p>Returns:</p> Type Description <code>Environment</code> <p>The created environment (InternalEnvironment if dependencies are met in the main environment and not forceExternal, ExternalEnvironment otherwise).</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def create(\n    self,\n    environment: str,\n    dependencies: Dependencies = {},\n    additionalInstallCommands: Commands = {},\n    forceExternal: bool = False,\n) -&gt; Environment:\n    \"\"\"Creates a new Conda environment with specified dependencie or the main environment if dependencies are met in the main environment and forceExternal is False (in which case additional install commands will not be called). Return the existing environment if it was already created.\n\n    Args:\n            environment: Name for the new environment. Ignore if dependencies are already installed in the main environment and forceExternal is False.\n            dependencies: Dependencies to install, in the form dict(python=\"3.12.7\", conda=[\"conda-forge::pyimagej==1.5.0\", dict(name=\"openjdk=11\", platforms=[\"osx-64\", \"osx-arm64\", \"win-64\", \"linux-64\"], dependencies=True, optional=False)], pip=[\"numpy==1.26.4\"]).\n            additionalInstallCommands: Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).\n            forceExternal: force create external environment even if dependencies are met in main environment\n\n    Returns:\n            The created environment (InternalEnvironment if dependencies are met in the main environment and not forceExternal, ExternalEnvironment otherwise).\n    \"\"\"\n    if self.environmentExists(environment):\n        if environment not in self.environments:\n            self.environments[environment] = ExternalEnvironment(environment, self)\n        return self.environments[environment]\n    if not forceExternal and self._dependenciesAreInstalled(dependencies):\n        return self.mainEnvironment\n    pythonVersion = dependencies.get(\"python\", \"\").replace(\"=\", \"\")\n    match = re.search(r\"(\\d+)\\.(\\d+)\", pythonVersion)\n    if match and (int(match.group(1)) &lt; 3 or int(match.group(2)) &lt; 9):\n        raise Exception(\"Python version must be greater than 3.8\")\n    pythonRequirement = \" python=\" + (pythonVersion if len(pythonVersion) &gt; 0 else platform.python_version())\n    createEnvCommands = self.commandGenerator.getActivateCondaCommands()\n    createEnvCommands += [f\"{self.settingsManager.condaBinConfig} create -n {environment}{pythonRequirement} -y\"]\n    createEnvCommands += self.dependencyManager.getInstallDependenciesCommands(environment, dependencies)\n    createEnvCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n    self.commandExecutor.executeCommandAndGetOutput(createEnvCommands)\n    self.environments[environment] = ExternalEnvironment(environment, self)\n    return self.environments[environment]\n</code></pre>"},{"location":"reference/cema/environment_manager/#cema.environment_manager.EnvironmentManager.environmentExists","title":"<code>environmentExists(environment)</code>","text":"<p>Checks if a Conda environment exists.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>str</code> <p>Environment name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if environment exists, False otherwise.</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def environmentExists(self, environment: str) -&gt; bool:\n    \"\"\"Checks if a Conda environment exists.\n\n    Args:\n            environment: Environment name to check.\n\n    Returns:\n            True if environment exists, False otherwise.\n    \"\"\"\n    condaMeta = Path(self.settingsManager.condaPath) / \"envs\" / environment / \"conda-meta\"\n    return condaMeta.is_dir()\n</code></pre>"},{"location":"reference/cema/environment_manager/#cema.environment_manager.EnvironmentManager.executeCommands","title":"<code>executeCommands(environmentName, commands, additionalActivateCommands={}, popenKwargs={})</code>","text":"<p>Executes the given commands in the given environment.</p> <p>Parameters:</p> Name Type Description Default <code>environmentName</code> <code>str | None</code> <p>The environment in which to execute commands.</p> required <code>commands</code> <code>Commands</code> <p>The commands to execute in the environment.</p> required <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>popenKwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen(). See :meth:<code>CommandExecutor.executeCommands</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Popen</code> <p>The launched process.</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def executeCommands(\n    self,\n    environmentName: str | None,\n    commands: Commands,\n    additionalActivateCommands: Commands = {},\n    popenKwargs: dict[str, Any] = {},\n) -&gt; subprocess.Popen:\n    \"\"\"Executes the given commands in the given environment.\n\n    Args:\n            environmentName: The environment in which to execute commands.\n            commands: The commands to execute in the environment.\n            additionalActivateCommands: Platform-specific activation commands.\n            popenKwargs: Keyword arguments for subprocess.Popen(). See :meth:`CommandExecutor.executeCommands`.\n\n    Returns:\n            The launched process.\n    \"\"\"\n    activateCommands = self.commandGenerator.getActivateEnvironmentCommands(\n        environmentName, additionalActivateCommands\n    )\n    platformCommands = self.commandGenerator.getCommandsForCurrentPlatform(commands)\n    return self.commandExecutor.executeCommands(activateCommands + platformCommands, popenKwargs=popenKwargs)\n</code></pre>"},{"location":"reference/cema/environment_manager/#cema.environment_manager.EnvironmentManager.install","title":"<code>install(environmentName, dependencies, additionalInstallCommands={})</code>","text":"<p>Installs dependencies. See :meth:<code>EnvironmentManager.create</code> for more details on the <code>dependencies</code> and <code>additionalInstallCommands</code> parameters.</p> <p>Parameters:</p> Name Type Description Default <code>environmentName</code> <code>str | None</code> <p>The environment to install dependencies.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Output lines of the installation commands.</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def install(\n    self, environmentName: str | None, dependencies: Dependencies, additionalInstallCommands: Commands = {}\n) -&gt; list[str]:\n    \"\"\"Installs dependencies.\n    See :meth:`EnvironmentManager.create` for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n    Args:\n            environmentName: The environment to install dependencies.\n            dependencies: Dependencies to install.\n            additionalInstallCommands: Platform-specific commands during installation.\n\n    Returns:\n            Output lines of the installation commands.\n    \"\"\"\n    installCommands = self.commandGenerator.getActivateCondaCommands()\n    installCommands += self.dependencyManager.getInstallDependenciesCommands(environmentName, dependencies)\n    installCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n    return self.commandExecutor.executeCommandAndGetOutput(installCommands)\n</code></pre>"},{"location":"reference/cema/environment_manager/#cema.environment_manager.EnvironmentManager.setCondaPath","title":"<code>setCondaPath(condaPath)</code>","text":"<p>Updates the micromamba path and loads proxy settings if exists.</p> <p>Parameters:</p> Name Type Description Default <code>condaPath</code> <code>str | Path</code> <p>New path to micromamba binary.</p> required Side Effects <p>Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def setCondaPath(self, condaPath: str | Path) -&gt; None:\n    \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n    Args:\n            condaPath: New path to micromamba binary.\n\n    Side Effects:\n            Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.\n    \"\"\"\n    self.settingsManager.setCondaPath(condaPath)\n</code></pre>"},{"location":"reference/cema/environment_manager/#cema.environment_manager.EnvironmentManager.setProxies","title":"<code>setProxies(proxies)</code>","text":"<p>Configures proxy settings for Conda operations.</p> <p>Parameters:</p> Name Type Description Default <code>proxies</code> <code>dict[str, str]</code> <p>Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).</p> required Side Effects <p>Updates .mambarc configuration file with proxy settings.</p> Source code in <code>cema/environment_manager.py</code> <pre><code>def setProxies(self, proxies: dict[str, str]) -&gt; None:\n    \"\"\"Configures proxy settings for Conda operations.\n\n    Args:\n            proxies: Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).\n\n    Side Effects:\n            Updates .mambarc configuration file with proxy settings.\n    \"\"\"\n    self.settingsManager.setProxies(proxies)\n</code></pre>"},{"location":"reference/cema/external_environment/","title":"External environment","text":""},{"location":"reference/cema/external_environment/#cema.external_environment.ExternalEnvironment","title":"<code>ExternalEnvironment</code>","text":"<p>               Bases: <code>Environment</code></p> Source code in <code>cema/external_environment.py</code> <pre><code>class ExternalEnvironment(Environment):\n    port: int | None = None\n    process: subprocess.Popen | None = None\n    connection: Connection | None = None\n\n    def __init__(self, name: str, environmentManager: \"EnvironmentManager\") -&gt; None:\n        super().__init__(name, environmentManager)\n\n    def logOutput(self) -&gt; None:\n        \"\"\"Logs output from the subprocess.\"\"\"\n        if self.process is None or self.process.stdout is None or self.process.stdout.readline is None:\n            return\n        try:\n            for line in iter(self.process.stdout.readline, \"\"):  # Use iter to avoid buffering issues:\n                # iter(callable, sentinel) repeatedly calls callable (process.stdout.readline) until it returns the sentinel value (\"\", an empty string).\n                # Since readline() is called directly in each iteration, it immediately processes available output instead of accumulating it in a buffer.\n                # This effectively forces line-by-line reading in real-time rather than waiting for the subprocess to fill its buffer.\n                logger.info(line.strip())\n        except Exception as e:\n            logger.error(f\"Exception in logging thread: {e}\")\n        return\n\n    def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n        \"\"\"Launches a server listening for orders in the environment.\n\n        Args:\n                additionalActivateCommands: Platform-specific activation commands.\n                logOutputInThread: Logs the process output in a separate thread.\n        \"\"\"\n\n        moduleExecutorPath = Path(__file__).parent.resolve() / \"_internal\" / \"module_executor.py\"\n\n        commands = self.environmentManager.commandGenerator.getActivateEnvironmentCommands(\n            self.name, additionalActivateCommands\n        )\n        commands += [f'python -u \"{moduleExecutorPath}\" {self.name}']\n        self.process = self.executeCommands(commands)\n\n        if self.process.stdout is not None:\n            try:\n                for line in self.process.stdout:\n                    logger.info(line.strip())\n                    if line.strip().startswith(\"Listening port \"):\n                        self.port = int(line.strip().replace(\"Listening port \", \"\"))\n                        break\n            except Exception as e:\n                self.process.stdout.close()\n                raise e\n        if self.process.poll() is not None:\n            if self.process.stdout is not None:\n                self.process.stdout.close()\n            raise Exception(f\"Process exited with return code {self.process.returncode}.\")\n        if self.port is None:\n            raise Exception(f\"Could not find the server port.\")\n        self.connection = Client((\"localhost\", self.port))\n\n        if logOutputInThread:\n            threading.Thread(target=self.logOutput, args=[]).start()\n\n    def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Executes a function in the given module and return the result.\n\n        Args:\n                modulePath: the path to the module to import\n                function: the name of the function to execute\n                args: the argument list for the function\n                kwargs: the keyword arguments for the function\n\n        Returns:\n                The result of the function if it is defined and the connection is opened ; None otherwise.\n        Raises:\n            OSError when raised by the communication.\n        \"\"\"\n        connection = self.connection\n        if connection is None or connection.closed:\n            logger.warning(f\"Connection not ready. Skipping execute {modulePath}.{function}({args})\")\n            return None\n        try:\n            connection.send(dict(action=\"execute\", modulePath=modulePath, function=function, args=args, kwargs=kwargs))\n            while message := connection.recv():\n                if message[\"action\"] == \"execution finished\":\n                    logger.info(\"execution finished\")\n                    return message.get(\"result\")\n                elif message[\"action\"] == \"error\":\n                    raise ExecutionException(message)\n                else:\n                    logger.warning(f\"Got an unexpected message: {message}\")\n        # If the connection was closed (subprocess killed): catch and ignore the exception, otherwise: raise it\n        except EOFError:\n            print(\"Connection closed gracefully by the peer.\")\n        except BrokenPipeError as e:\n            logger.error(f\"Broken pipe. The peer process might have terminated. Exception: {e}.\")\n        except OSError as e:\n            if e.errno == 9:  # Bad file descriptor\n                logger.error(\"Connection closed abruptly by the peer.\")\n            else:\n                logger.error(f\"Unexpected OSError: {e}\")\n                raise e\n        return None\n\n    def launched(self) -&gt; bool:\n        \"\"\"Return true if the environment server process is launched and the connection is open.\"\"\"\n        return (\n            self.process is not None\n            and self.process.poll() is None\n            and self.connection is not None\n            and not self.connection.closed\n            and self.connection.writable\n            and self.connection.readable\n        )\n\n    def _exit(self) -&gt; None:\n        \"\"\"Close the connection to the environment and kills the process.\"\"\"\n        if self.connection is not None:\n            try:\n                self.connection.send(dict(action=\"exit\"))\n            except OSError as e:\n                if e.args[0] == \"handle is closed\":\n                    pass\n            self.connection.close()\n\n        CommandExecutor.killProcess(self.process)\n</code></pre>"},{"location":"reference/cema/external_environment/#cema.external_environment.ExternalEnvironment.execute","title":"<code>execute(modulePath, function, args=(), kwargs={})</code>","text":"<p>Executes a function in the given module and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>modulePath</code> <code>str | Path</code> <p>the path to the module to import</p> required <code>function</code> <code>str</code> <p>the name of the function to execute</p> required <code>args</code> <code>tuple</code> <p>the argument list for the function</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>the keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the function if it is defined and the connection is opened ; None otherwise.</p> <p>Raises:     OSError when raised by the communication.</p> Source code in <code>cema/external_environment.py</code> <pre><code>def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Executes a function in the given module and return the result.\n\n    Args:\n            modulePath: the path to the module to import\n            function: the name of the function to execute\n            args: the argument list for the function\n            kwargs: the keyword arguments for the function\n\n    Returns:\n            The result of the function if it is defined and the connection is opened ; None otherwise.\n    Raises:\n        OSError when raised by the communication.\n    \"\"\"\n    connection = self.connection\n    if connection is None or connection.closed:\n        logger.warning(f\"Connection not ready. Skipping execute {modulePath}.{function}({args})\")\n        return None\n    try:\n        connection.send(dict(action=\"execute\", modulePath=modulePath, function=function, args=args, kwargs=kwargs))\n        while message := connection.recv():\n            if message[\"action\"] == \"execution finished\":\n                logger.info(\"execution finished\")\n                return message.get(\"result\")\n            elif message[\"action\"] == \"error\":\n                raise ExecutionException(message)\n            else:\n                logger.warning(f\"Got an unexpected message: {message}\")\n    # If the connection was closed (subprocess killed): catch and ignore the exception, otherwise: raise it\n    except EOFError:\n        print(\"Connection closed gracefully by the peer.\")\n    except BrokenPipeError as e:\n        logger.error(f\"Broken pipe. The peer process might have terminated. Exception: {e}.\")\n    except OSError as e:\n        if e.errno == 9:  # Bad file descriptor\n            logger.error(\"Connection closed abruptly by the peer.\")\n        else:\n            logger.error(f\"Unexpected OSError: {e}\")\n            raise e\n    return None\n</code></pre>"},{"location":"reference/cema/external_environment/#cema.external_environment.ExternalEnvironment.launch","title":"<code>launch(additionalActivateCommands={}, logOutputInThread=True)</code>","text":"<p>Launches a server listening for orders in the environment.</p> <p>Parameters:</p> Name Type Description Default <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>logOutputInThread</code> <code>bool</code> <p>Logs the process output in a separate thread.</p> <code>True</code> Source code in <code>cema/external_environment.py</code> <pre><code>def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n    \"\"\"Launches a server listening for orders in the environment.\n\n    Args:\n            additionalActivateCommands: Platform-specific activation commands.\n            logOutputInThread: Logs the process output in a separate thread.\n    \"\"\"\n\n    moduleExecutorPath = Path(__file__).parent.resolve() / \"_internal\" / \"module_executor.py\"\n\n    commands = self.environmentManager.commandGenerator.getActivateEnvironmentCommands(\n        self.name, additionalActivateCommands\n    )\n    commands += [f'python -u \"{moduleExecutorPath}\" {self.name}']\n    self.process = self.executeCommands(commands)\n\n    if self.process.stdout is not None:\n        try:\n            for line in self.process.stdout:\n                logger.info(line.strip())\n                if line.strip().startswith(\"Listening port \"):\n                    self.port = int(line.strip().replace(\"Listening port \", \"\"))\n                    break\n        except Exception as e:\n            self.process.stdout.close()\n            raise e\n    if self.process.poll() is not None:\n        if self.process.stdout is not None:\n            self.process.stdout.close()\n        raise Exception(f\"Process exited with return code {self.process.returncode}.\")\n    if self.port is None:\n        raise Exception(f\"Could not find the server port.\")\n    self.connection = Client((\"localhost\", self.port))\n\n    if logOutputInThread:\n        threading.Thread(target=self.logOutput, args=[]).start()\n</code></pre>"},{"location":"reference/cema/external_environment/#cema.external_environment.ExternalEnvironment.launched","title":"<code>launched()</code>","text":"<p>Return true if the environment server process is launched and the connection is open.</p> Source code in <code>cema/external_environment.py</code> <pre><code>def launched(self) -&gt; bool:\n    \"\"\"Return true if the environment server process is launched and the connection is open.\"\"\"\n    return (\n        self.process is not None\n        and self.process.poll() is None\n        and self.connection is not None\n        and not self.connection.closed\n        and self.connection.writable\n        and self.connection.readable\n    )\n</code></pre>"},{"location":"reference/cema/external_environment/#cema.external_environment.ExternalEnvironment.logOutput","title":"<code>logOutput()</code>","text":"<p>Logs output from the subprocess.</p> Source code in <code>cema/external_environment.py</code> <pre><code>def logOutput(self) -&gt; None:\n    \"\"\"Logs output from the subprocess.\"\"\"\n    if self.process is None or self.process.stdout is None or self.process.stdout.readline is None:\n        return\n    try:\n        for line in iter(self.process.stdout.readline, \"\"):  # Use iter to avoid buffering issues:\n            # iter(callable, sentinel) repeatedly calls callable (process.stdout.readline) until it returns the sentinel value (\"\", an empty string).\n            # Since readline() is called directly in each iteration, it immediately processes available output instead of accumulating it in a buffer.\n            # This effectively forces line-by-line reading in real-time rather than waiting for the subprocess to fill its buffer.\n            logger.info(line.strip())\n    except Exception as e:\n        logger.error(f\"Exception in logging thread: {e}\")\n    return\n</code></pre>"},{"location":"reference/cema/internal_environment/","title":"Internal environment","text":""},{"location":"reference/cema/internal_environment/#cema.internal_environment.InternalEnvironment","title":"<code>InternalEnvironment</code>","text":"<p>               Bases: <code>Environment</code></p> Source code in <code>cema/internal_environment.py</code> <pre><code>class InternalEnvironment(Environment):\n    def __init__(self, name: Path | str | None, environmentManager: \"EnvironmentManager\") -&gt; None:\n        super().__init__(self._addTrailingSlash(name), environmentManager)\n\n    def _addTrailingSlash(self, path: Path | str | None) -&gt; str | None:\n        # https://stackoverflow.com/questions/47572165/whats-the-best-way-to-add-a-trailing-slash-to-a-pathlib-directory\n        if path is None:\n            return path\n        return str(Path(path) / \"_\")[:-1]\n\n    def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n        \"\"\"Raise an exception. See :meth:`Environment.launch` and :meth:`ExternalEnvironment.launch`\"\"\"\n        raise Exception(\"Cannot launch the main environment.\")\n\n    def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Executes a function in the given module\n\n        Args:\n                modulePath: the path to the module to import\n                function: the name of the function to execute\n                args: the argument list for the function\n                kwargs: the keyword arguments for the function\n\n        Returns:\n                The result of the function\n        \"\"\"\n        module = self._importModule(modulePath)\n        if not self._isModFunction(module, function):\n            raise Exception(f\"Module {modulePath} has no function {function}.\")\n        return getattr(module, function)(*args)\n</code></pre>"},{"location":"reference/cema/internal_environment/#cema.internal_environment.InternalEnvironment.execute","title":"<code>execute(modulePath, function, args=(), kwargs={})</code>","text":"<p>Executes a function in the given module</p> <p>Parameters:</p> Name Type Description Default <code>modulePath</code> <code>str | Path</code> <p>the path to the module to import</p> required <code>function</code> <code>str</code> <p>the name of the function to execute</p> required <code>args</code> <code>tuple</code> <p>the argument list for the function</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>the keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the function</p> Source code in <code>cema/internal_environment.py</code> <pre><code>def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Executes a function in the given module\n\n    Args:\n            modulePath: the path to the module to import\n            function: the name of the function to execute\n            args: the argument list for the function\n            kwargs: the keyword arguments for the function\n\n    Returns:\n            The result of the function\n    \"\"\"\n    module = self._importModule(modulePath)\n    if not self._isModFunction(module, function):\n        raise Exception(f\"Module {modulePath} has no function {function}.\")\n    return getattr(module, function)(*args)\n</code></pre>"},{"location":"reference/cema/internal_environment/#cema.internal_environment.InternalEnvironment.launch","title":"<code>launch(additionalActivateCommands={}, logOutputInThread=True)</code>","text":"<p>Raise an exception. See :meth:<code>Environment.launch</code> and :meth:<code>ExternalEnvironment.launch</code></p> Source code in <code>cema/internal_environment.py</code> <pre><code>def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n    \"\"\"Raise an exception. See :meth:`Environment.launch` and :meth:`ExternalEnvironment.launch`\"\"\"\n    raise Exception(\"Cannot launch the main environment.\")\n</code></pre>"}]}