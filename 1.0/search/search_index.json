{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wetlands - Conda Environment Manager","text":"<p>Wetlands is a lightweight Python library for managing Conda environments.</p> <p>Wetlands can create Conda environments on demand, install dependencies, and execute arbitrary code within them. This makes it easy to build plugin systems or integrate external modules into an application without dependency conflicts, as each environment remains isolated.</p> <p>The name Wetlands comes from the tropical environnements where Anacondas thrive.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>Automatic Environment Management: Create and configure environments on demand.</li> <li>Dependency Isolation: Install dependencies without conflicts.</li> <li>Embedded Execution: Run Python functions inside isolated environments.</li> <li>Micromamba: Wetlands uses a self-contained <code>micromamba</code> for fast and lightweight Conda environment handling.</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>To install Wetlands, simply run:</p> <pre><code>pip install wetlands\n</code></pre>"},{"location":"#usage","title":"\ud83d\ude80 Usage","text":""},{"location":"#minimal-example","title":"Minimal example","text":"<p>Here is a minimal example usage:</p> <pre><code>from wetlands.environment_manager import EnvironmentManager\n\n# Initialize the environment manager\nenvironmentManager = EnvironmentManager(\"micromamba/\")\n\n# Create and launch a Conda environment named \"numpy_env\"\nenv = environmentManager.create(\"numpy_env\", {\"pip\": [\"numpy==2.2.4\"]})\nenv.launch()\n\n# Import minimal_module in the environment (see minimal_module.py below)\nminimal_module = env.importModule(\"minimal_module.py\")\n# minimal_module is a proxy to minimal_module.py in the environment\narray = [1, 2, 3]\n# Execute the sum() function in the numpy_env environment and get the result\nresult = minimal_module.sum(array)\n\nprint(f\"Sum of {array} is {result}.\")\n\n# Clean up and exit the environment\nenv.exit()\n</code></pre> <p>With <code>minimal_module.py</code>:</p> <pre><code>def sum(x):\n    import numpy as np  # type: ignore\n    return int(np.sum(x))\n</code></pre>"},{"location":"#general-usage","title":"General usage","text":"<p>Wetlands allows you to interact with isolated Conda environments in two main ways:</p> <ol> <li>Simplified Execution (<code>env.importModule</code> / <code>env.execute</code>): Wetlands manages the communication details, providing a proxy object to call functions within the environment seamlessly. See Getting started.</li> <li>Manual Control (<code>env.executeCommands</code>): You run specific commands (like starting a Python script that listens for connections) and manage the inter-process communication yourself. See Advanced example.</li> </ol> <p>You can run those examples form the <code>examples/</code> folder in the repository.</p> <p>Explore the inner workings on the How it Works page.</p>"},{"location":"advanced_example/","title":"Advanced example","text":""},{"location":"advanced_example/#manual-communication-with-envexecutecommands","title":"Manual Communication with <code>env.executeCommands</code>","text":"<p>This example shows how to use Wetlands to run a specific script within the environment and manage the communication manually using Python's <code>multiprocessing.connection</code>. This gives you full control over the interaction protocol but requires more setup.</p> <p>Let's see the main script <code>advanced_example.py</code> step by step. </p>"},{"location":"advanced_example/#initialize-wetlands-and-logging","title":"Initialize Wetlands and Logging","text":"<p>We import necessary modules, including <code>Client</code> for manual connection and standard Python libraries like <code>subprocess</code>, <code>threading</code>, and <code>logging</code>. We also enable debug logging for Wetlands to see more internal details and initialize the <code>EnvironmentManager</code>.</p> <pre><code># main_script_manual.py\nfrom multiprocessing.connection import Client\nimport subprocess\nimport sys\nimport threading\nimport logging\nfrom pathlib import Path\nimport time\n\nfrom wetlands.environment_manager import EnvironmentManager\nfrom wetlands import logger\n\nlogger.setLogLevel(logging.DEBUG)\nenvironmentManager = EnvironmentManager(\"micromamba/\")\n</code></pre>"},{"location":"advanced_example/#create-the-environment","title":"Create the Environment","text":"<p>Similar to the first example, we create the environment (<code>advanced_cellpose_env</code>) and specify its dependencies.</p> <pre><code>deps = {\"conda\": [\"cellpose==3.1.0\"]}\nenv = environmentManager.create(\"advanced_cellpose_env\", deps)\n</code></pre>"},{"location":"advanced_example/#execute-a-custom-script-in-the-environment","title":"Execute a Custom Script in the Environment","text":"<p>Instead of <code>env.launch()</code>, we use <code>env.executeCommands()</code>. This method allows us to run arbitrary shell commands within the activated environment. Here, we execute a specific Python script (<code>advanced_example_module.py</code>) using <code>python -u</code> (unbuffered output, important for reading stdout line-by-line immediately). We capture the <code>Popen</code> object for the launched process. We also redirect stderr to stdout for easier log capture.</p> <pre><code>print(\"Executing advanced_example_module.py in environment...\")\nprocess = env.executeCommands([\"python -u advanced_example_module.py\"])\n</code></pre>"},{"location":"advanced_example/#establish-manual-connection","title":"Establish Manual Connection","text":"<p>The script we just launched (<code>advanced_example_module.py</code>) is designed to start a server and print the port it's listening on to its standard output. Our main script now needs to read the <code>stdout</code> of the <code>process</code> launched by Wetlands to discover this port number. We loop through the output lines until we find the line indicating the port.</p> <pre><code>port = None\nif process.stdout is None:\n    print(\"Process has no stdout stream.\", file=sys.stderr)\n    sys.exit(1)\nprint(\"Waiting for environment process to report listening port...\")\nfor line in process.stdout:\n    if line.strip().startswith(\"Listening port \"):\n        port = int(line.strip().replace(\"Listening port \", \"\"))\n        break\n\nprint(f\"Connecting to localhost:{port}...\")\nconnection = Client((\"localhost\", port))\n</code></pre>"},{"location":"advanced_example/#log-environment-output-optional","title":"Log Environment Output (Optional)","text":"<p>To see ongoing output from the script running in the environment, we can start a background thread that continuously reads and prints lines from the process's stdout.</p> <pre><code>def log_output(proc: subprocess.Popen):\n    if proc.stdout:\n        for line_bytes in iter(proc.stdout.readline, b''):\n            print(f\"[Env Output]: {line_bytes.decode().strip()}\")\n\noutput_thread = threading.Thread(target=log_output, args=(process,), daemon=True)\noutput_thread.start()\n</code></pre>"},{"location":"advanced_example/#send-commands-and-receive-results-manually","title":"Send Commands and Receive Results Manually","text":"<p>Now that we have a direct <code>connection</code> object (from <code>multiprocessing.connection.Client</code>), we can implement our own communication protocol. We send dictionaries containing an <code>action</code>, <code>function</code> name, and <code>args</code>. We then wait (<code>connection.recv()</code>) for a response dictionary from the server script running in the environment.</p> <pre><code>imagePath = \"cellpose_img02.png\"\n\nprint(f\"Sending command: download image {imagePath}\")\nconnection.send(dict(action=\"execute\", function=\"downloadImage\", args=[imagePath]))\nresult = connection.recv()\nprint(f\"Received response: {result}\")\n\nsegmentationPath = \"cellpose_img02_segmentation.png\"\nprint(f\"Sending command: segment image {imagePath}\")\nargs = [str(imagePath), str(segmentationPath)]\nconnection.send(dict(action=\"execute\", function=\"segmentImage\", args=args))\nresult = connection.recv()\nprint(f\"Received response: {result}\")\nif 'diameters' in result:\n    print(f\"Object diameters: {result['diameters']}\")\n</code></pre>"},{"location":"advanced_example/#tell-the-environment-process-to-exit-and-clean-up","title":"Tell the Environment Process to Exit and clean up","text":"<p>We send a custom 'exit' message according to our protocol. The server script is designed to shut down upon receiving this message.</p> <pre><code>print(\"Sending exit command...\")\nconnection.send(dict(action=\"exit\"))\n</code></pre> <p>We close our client-side connection and wait for the process we launched with <code>executeCommands</code> to terminate.</p> <pre><code>connection.close()\nprocess.wait(timeout=10)\nif process.returncode is None:\n    process.kill()\n</code></pre> <p>Now, let's examine the <code>advanced_example_module.py</code> script, which is executed by Wetlands in the isolated environment via <code>executeCommands</code>.</p> <p>Define Callable Functions</p> <p>This script defines the functions (<code>downloadImage</code>, <code>segmentImage</code>) that the main script will invoke remotely. These functions perform the actual work (downloading, segmenting using <code>example_module</code>) inside the environment and use the provided <code>connection</code> object to send back results or status messages.</p> <pre><code># advanced_example_module.py\nimport sys\nimport requests\nfrom multiprocessing.connection import Listener\nfrom pathlib import Path\nimport example_module # Reuse logic from the simple example module\n\ndef downloadImage(imagePath_str, connection):\n    \"\"\"Downloads the image *inside* the environment.\"\"\"\n    imagePath = Path(imagePath_str)\n    print(f\"[Inside Env] Downloading image to {imagePath}...\")\n    try:\n        imageData = requests.get(\"https://www.cellpose.org/static/images/img02.png\").content\n        with open(imagePath, \"wb\") as handler:\n            handler.write(imageData)\n        print(\"[Inside Env] Image downloaded.\")\n        connection.send(dict(status=\"success\", message=\"Image downloaded.\"))\n    except Exception as e:\n        print(f\"[Inside Env] Error downloading image: {e}\")\n        connection.send(dict(status=\"error\", message=str(e)))\n\ndef segmentImage(imagePath_str, segmentationPath_str, connection):\n    \"\"\"Runs segmentation *inside* the environment.\"\"\"\n    imagePath = Path(imagePath_str)\n    segmentationPath = Path(segmentationPath_str)\n    print(f\"[Inside Env] Segmenting {imagePath}...\")\n    try:\n        diameters = example_module.segment(imagePath, segmentationPath)\n        print(\"[Inside Env] Segmentation complete.\")\n        connection.send(dict(status=\"success\", message=\"Image segmented.\", diameters=diameters))\n    except Exception as e:\n        print(f\"[Inside Env] Error during segmentation: {e}\")\n        connection.send(dict(status=\"error\", message=str(e)))\n</code></pre> <p>Set Up the Server</p> <p>The main part of the script uses <code>multiprocessing.connection.Listener</code> to create a server socket listening on <code>localhost</code> and an OS-assigned port (<code>0</code>). Crucially, it prints the chosen port number to standard output, which is how the main script discovers where to connect. It then waits for the main script to connect (<code>listener.accept()</code>).</p> <pre><code>with Listener((\"localhost\", 0)) as listener:\n    # Print the port for the main process to read\n    print(f\"Listening port {listener.address[1]}\", flush=True)\n    with listener.accept() as connection:\n</code></pre> <p>Process Incoming Messages</p> <p>Once connected, the script enters a loop, waiting to receive messages (<code>connection.recv()</code>). It parses the received dictionary, checks the <code>action</code>, and calls the corresponding local function (<code>downloadImage</code> or <code>segmentImage</code>) if the action is <code>execute</code>. If the action is <code>exit</code>, it sends a confirmation and terminates the script (<code>sys.exit(0)</code>).</p> <pre><code>        while message := connection.recv():\n            if message[\"action\"] == \"execute\":\n                locals()[message[\"function\"]](*(message[\"args\"] + [connection]))\n            if message[\"action\"] == \"exit\":\n                connection.send(dict(action=\"Exited.\"))\n                sys.exit(0)\n</code></pre> <p>Summary of Example 2 Flow:</p> <p>The main script uses <code>EnvironmentManager</code> to create an environment. <code>env.executeCommands()</code> starts a custom server script (<code>advanced_example_module.py</code>) inside the environment. The main script reads the server's port from stdout and connects manually using <code>Client</code>. Communication happens via custom message dictionaries sent over this connection. The main script explicitly tells the server to exit before cleaning up the process started by <code>executeCommands</code>. This approach offers more control but requires implementing the server logic and communication protocol.</p>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#simplified-execution-with-envimportmodule","title":"Simplified Execution with <code>env.importModule</code>","text":"<p>To demonstrates the most straightforward way to use Wetlands, we will create an environment, install <code>cellpose</code>, and run a segmentation function defined in a separate file (<code>example_module.py</code>) within that isolated environment.</p> <p>Let's see the main script <code>getting_started.py</code> step by step. </p> <p>We will segment the image <code>img02.png</code> (available here).</p> <pre><code>imagePath = \"img02.png\"\nsegmentationPath = \"img02_segmentation.png\"\n</code></pre>"},{"location":"getting_started/#1-initialize-the-environment-manager","title":"1. Initialize the Environment Manager","text":"<p>We start by initializing the EnvironmentManager. We provide a path (<code>\"micromamba/\"</code>) where Wetlands should look for an existing Micromamba installation or where it should download and set up a new one if it's not found.</p> <pre><code>from wetlands.environment_manager import EnvironmentManager\nimport requests\nfrom pathlib import Path\n\nenvironmentManager = EnvironmentManager(\"micromamba/\")\n</code></pre> <p>Note</p> <p>EnvironmentManager also accepts a <code>mainCondaEnvironmentPath</code> argument, useful if Wetlands is used in a conda environment (e.g. <code>environmentManager = EnvironmentManager(\"micromamba/\", \"/path/to/project/environment/\")</code>). Wetlands will activate this main environment and check if the installed packages satisfy the requirements when creating new environments. If the required dependencies are already installed in the main environment, EnvironmentManager.create() will return the main enviroment instead of creating a new one. The modules will be called directly, bypassing the Wetlands communication server.</p>"},{"location":"getting_started/#2-create-or-get-an-environment-and-install-dependencies","title":"2. Create (or get) an Environment and Install Dependencies","text":"<p>Next, we define and create the Conda environment. We give it a name (<code>\"cellpose_env\"</code>) and specify its dependencies using a dictionary. Here, we require <code>cellpose</code> version 3.1.0, to be installed via Conda. If an environment with this name already exists, Wetlands will use it (and ignore the dependencies); otherwise, it will create it and install the specified dependencies. The <code>create</code> method returns an <code>Environment</code> object.</p> <pre><code>env = environmentManager.create(\n    \"cellpose_env\",\n    {\"conda\": [\"cellpose==3.1.0\"]}\n)\n</code></pre> <p>Note</p> <p>If a <code>mainCondaEnvironmentPath</code> was provided when instanciating the <code>EnvironmentManager</code>, Wetlands will check if <code>cellpose==3.1.0</code> is already installed in the main environment and return it if it is the case. If <code>mainCondaEnvironmentPath</code> is not provided but the required dependencies are only pip packages, Wetlands will check if the dependencies are installed in the current python environment and return it if it is the case.</p>"},{"location":"getting_started/#3-launch-the-environments-communication-server","title":"3. Launch the Environment's Communication Server","text":"<p>For Wetlands to execute code within the isolated environment (using <code>importModule</code> or <code>execute</code>), we need to launch its background communication server. This server runs as a separate process inside the <code>cellpose_env</code> and listens for commands from our main script.</p> <pre><code>env.launch()\n</code></pre>"},{"location":"getting_started/#4-import-and-execute-code-in-the-environment-via-proxy","title":"4. Import and Execute Code in the Environment via Proxy","text":"<p>This is where the core Wetlands interaction happens. We use <code>env.importModule(\"example_module.py\")</code> to gain access to the functions defined in <code>example_module.py</code>. Wetlands doesn't actually import the module into the main process; instead, it returns a proxy object. When we call a method on this proxy object (like <code>example_module.segment(...)</code>), Wetlands intercepts the call, sends the function name and arguments to the server running in the <code>cellpose_env</code>, executes the real function there, and returns the result back to the main script. File paths and other pickleable arguments are automatically transferred.</p> <pre><code>print(\"Importing module in environment...\")\nexample_module = env.importModule(\"example_module.py\")\n\nprint(f\"Running segmentation on {imagePath}...\")\ndiameters = example_module.segment(imagePath, segmentationPath)\n\nprint(f\"Segmentation complete. Found diameters of {diameters} pixels.\")\n</code></pre> <p>Alternatively, we could use <code>env.execute()</code> directly:</p> <pre><code>print(f\"Running segmentation on {imagePath}...\")\nargs = (imagePath, segmentationPath)\ndiameters = env.execute(\"example_module.py\", \"segment\", args)\n\nprint(f\"Segmentation complete. Found diameters of {diameters} pixels.\")\n</code></pre>"},{"location":"getting_started/#5-clean-up","title":"5. Clean Up","text":"<p>Finally, we tell Wetlands to shut down the communication server and clean up resources associated with the launched environment.</p> <pre><code>print(\"Exiting environment...\")\nenv.exit()\n\nprint(\"Done.\")\n</code></pre> <code>getting_started.py</code> source code <pre><code>from wetlands.environment_manager import EnvironmentManager\nimport requests\n\n# Declare our input and output paths\nimagePath = \"img02.png\"\nsegmentationPath = \"img02_segmentation.png\"\n\n# Initialize the environment manager\n# Wetlands will use the existing Micromamba installation at the specified path (e.g., \"micromamba/\") if available;\n# otherwise it will automatically download and install Micromamba in a self-contained manner.\nenvironmentManager = EnvironmentManager(\"micromamba/\")\n\n# Create and launch an isolated Conda environment named \"cellpose\"\nenv = environmentManager.create(\"cellpose\", {\"conda\": [\"cellpose==3.1.0\"]})\nenv.launch()\n\n# Import example_module in the environment\nexample_module = env.importModule(\"example_module.py\")\n# example_module is a proxy to example_module.py in the environment,\n# calling example_module.function_name(args) will run env.execute(module_name, function_name, args)\ndiameters = example_module.segment(imagePath, segmentationPath)\n\n# Or use env.execute() directly\n# diameters = env.execute(\"example_module.py\", \"segment\", (imagePath, segmentationPath))\n\nprint(f\"Found diameters of {diameters} pixels.\")\n\n# Clean up and exit the environment\nenv.exit()\n</code></pre> <p>Now, let's look at the <code>example_module.py</code> file. This code contains the actual segmentation logic and is executed inside the isolated <code>cellpose_env</code> when called via the proxy object.</p>"},{"location":"getting_started/#define-the-segmentation-function","title":"Define the Segmentation Function","text":"<p>The module defines a <code>segment</code> function that takes input/output paths and other parameters. It uses a global variable <code>model</code> to potentially cache the loaded Cellpose model between calls within the same environment process lifetime.</p> <pre><code># example_module.py\nfrom pathlib import Path\nfrom typing import Any, cast\n\nmodel = None\n\ndef segment(\n    input_image: Path | str,\n    segmentation: Path | str,\n    model_type=\"cyto\",\n    use_gpu=False,\n    channels=[0, 0],\n    auto_diameter=True,\n    diameter=30,\n):\n    \"\"\"Performs cell segmentation using Cellpose.\"\"\"\n    global model\n\n    input_image = Path(input_image)\n    if not input_image.exists():\n        raise FileNotFoundError(f\"Error: input image {input_image}\"\\\n                                \"does not exist.\")\n</code></pre>"},{"location":"getting_started/#import-dependencies-inside-the-environment","title":"Import Dependencies (Inside the Environment)","text":"<p>Crucially, the necessary libraries (<code>cellpose</code>, <code>numpy</code>) are imported within this function, meaning they are resolved using the packages installed inside the isolated <code>cellpose_env</code>, not the main script's environment. This is important to enable the main script to import <code>example_module.py</code> without raising a <code>ModuleNotFoundError</code>. In this way, the main script can see the functions defined in <code>example_module.py</code>. This is only necessary when using the proxy object (<code>env.importModule(\"example_module.py\")</code> then <code>example_module.function(args)</code>) but it is not required when using <code>env.execute(\"example_module.py\", \"function\", (args))</code> directly.</p> <pre><code>    print(f\"[[1/4]] Load libraries and model '{model_type}'\")\n    import cellpose.models\n    import cellpose.io\n    import numpy as np\n</code></pre> <p>Using try catch to prevent <code>ModuleNotFoundError</code></p> <p>A better approach is to use a try statement at the beginning of <code>example_module.py</code> to fail silently when importing modules which are not accessible in the main environment, like so:</p> <pre><code>try:\n    import cellpose.models\n    import cellpose.io\n    import numpy as np\nexcept ModuleNotFoundError:\n    pass\n...\n</code></pre> <p>This allows:  - to access the function definitions in the main environment (even if we won't be able to execute them in the main environment),  - to import the modules for all functions defined in <code>example_module.py</code> in the <code>cellpose_env</code>.</p>"},{"location":"getting_started/#load-model-and-process-image","title":"Load Model and Process Image","text":"<p>The code proceeds to load the Cellpose model (if not already cached) and the input image. All this happens within the context of the <code>cellpose_env</code>.</p> <pre><code>    if model is None or model.cp.model_type != model_type:\n        print(\"Loading model...\")\n        gpu_flag = str(use_gpu).lower() == 'true'\n        model = cellpose.models.Cellpose(gpu=gpu_flag, model_type=model_type)\n\n    print(f\"[[2/4]] Load image {input_image}\")\n    image = cast(np.ndarray, cellpose.io.imread(str(input_image)))\n</code></pre>"},{"location":"getting_started/#perform-segmentation","title":"Perform Segmentation","text":"<p>The core segmentation task is performed using the loaded model and image. Any exceptions raised here will be captured by Wetlands and re-raised in the main script.</p> <pre><code>    print(f\"[[3/4]] Compute segmentation for image shape {image.shape}\")\n    try:\n        kwargs: Any = dict(diameter=int(diameter)) if auto_diameter else {}\n        masks, _, _, diams = model.eval(image, channels=channels, **kwargs)\n    except Exception as e:\n        print(f\"Error during segmentation: {e}\")\n        raise e\n    print(\"Segmentation finished (inside environment).\")\n</code></pre>"},{"location":"getting_started/#save-results-and-return-value","title":"Save Results and Return Value","text":"<p>The segmentation results (masks) are saved to disk, potentially renaming the output file. The function then returns the calculated cell diameters (<code>diams</code>). This return value is serialized by Wetlands and sent back to the main script.</p> <pre><code>    segmentation_path = Path(segmentation)\n    print(f\"[[4/4]] Save segmentation to {segmentation_path}\")\n\n    cellpose.io.save_masks(image, masks, flows, str(input_image), png=True)\n    default_output = input_image.parent / f\"{input_image.stem}_cp_masks.png\"\n\n    if default_output.exists():\n        if segmentation_path.exists():\n            segmentation_path.unlink()\n        default_output.rename(segmentation_path)\n        print(f\"Saved mask: {segmentation_path}\")\n    else:\n        print(\"Warning: Segmentation mask file was not generated by cellpose.\")\n\n    return diams\n</code></pre> <code>example_module.py</code> source code <pre><code>from pathlib import Path\nfrom typing import Any, cast\n\nmodel = None\n\n\ndef segment(\n    input_image: Path | str,\n    segmentation: Path | str,\n    model_type=\"cyto\",\n    use_gpu=False,\n    channels=[0, 0],\n    auto_diameter=True,\n    diameter=30,\n):\n    global model\n\n    input_image = Path(input_image)\n    if not input_image.exists():\n        raise Exception(f\"Error: input image {input_image} does not exist.\")\n\n    print(f\"[[1/4]] Load libraries and model {model_type}\")\n    print(\"Loading libraries...\")\n    import cellpose.models  # type: ignore\n    import cellpose.io  # type: ignore\n    import numpy as np  # type: ignore\n\n    if model is None or model.cp.model_type != model_type:\n        print(\"Loading model...\")\n        model = cellpose.models.Cellpose(gpu=True if use_gpu == \"True\" else False, model_type=model_type)\n\n    print(f\"[[2/4]] Load image {input_image}\")\n    image = cast(np.ndarray, cellpose.io.imread(str(input_image)))\n\n    print(\"[[3/4]] Compute segmentation\", image.shape)\n    try:\n        kwargs: Any = dict(diameter=int(diameter)) if auto_diameter else {}\n        masks, flows, styles, diams = model.eval(image, channels=channels, **kwargs)\n    except Exception as e:\n        print(e)\n        raise e\n    print(\"segmentation finished.\")\n\n    segmentation = Path(segmentation)\n    print(f\"[[4/4]] Save segmentation {segmentation}\")\n    # save results as png\n    cellpose.io.save_masks(image, masks, flows, str(input_image), png=True)\n    output_mask = input_image.parent / f\"{input_image.stem}_cp_masks.png\"\n    if output_mask.exists():\n        if segmentation.exists():\n            segmentation.unlink()\n        (output_mask).rename(segmentation)\n        print(f\"Saved out: {segmentation}\")\n    else:\n        print(\"Segmentation was not generated because no masks were found.\")\n    return diams\n</code></pre>"},{"location":"getting_started/#summary-of-example-1-flow","title":"Summary of Example 1 Flow:","text":"<p>The main script uses <code>EnvironmentManager</code> to prepare an isolated environment. <code>env.launch()</code> starts a hidden server in that environment. <code>env.importModule()</code> provides a proxy, and calling functions on the proxy executes the code (like <code>example_module.segment</code>) within the isolated environment, handling data transfer automatically. <code>env.exit()</code> cleans up the server process.</p>"},{"location":"how_it_works/","title":"How it works","text":""},{"location":"how_it_works/#step-by-step","title":"\ud83c\udf93 Step by Step","text":"<p>Wetlands leverages Micromamba, a fast, native reimplementation of the Conda package manager.</p> <ol> <li>Micromamba Setup: When <code>EnvironmentManager</code> is initialized, it checks for a <code>micromamba</code> executable at the specified path (e.g., <code>\"micromamba/\"</code>). If not found, it downloads a self-contained Micromamba binary suitable for the current operating system and architecture into that directory. This means Wetlands doesn't require a pre-existing Conda/Mamba installation.</li> <li>Environment Creation: <code>create(name, dependencies)</code> uses Micromamba commands (<code>micromamba create -n name -c channel package ...</code>) to build a new, isolated Conda environment within the Micromamba prefix (e.g., <code>micromamba/envs/name</code>). Note that the main environemnt is returned if it already satisfies the required dependencies.</li> <li>Dependency Installation: Dependencies (Conda packages, Pip packages) are installed into the target environment using <code>micromamba install ...</code> and <code>pip install ...</code> (executed within the activated environment).</li> <li>Execution (<code>launch</code>/<code>execute</code>/<code>importModule</code>):<ul> <li><code>launch()</code> starts a helper Python script (<code>wetlands._internal.executor_server</code>) within the activated target environment using <code>subprocess.Popen</code>.</li> <li>This server listens on a local socket using <code>multiprocessing.connection.Listener</code>.</li> <li>The main process connects to this server using <code>multiprocessing.connection.Client</code>.</li> <li><code>execute(module, func, args)</code> sends a message containing the module path, function name, and arguments to the server.</li> <li>The server imports the module (if not already imported), executes the function with the provided arguments, and sends the result (or exception) back to the main process.</li> <li><code>importModule(module)</code> creates a proxy object in the main process. When methods are called on this proxy, it triggers the <code>execute</code> mechanism described above.</li> </ul> </li> <li>Direct Execution (<code>executeCommands</code>): This method directly activates the target environment and runs the provided shell commands using <code>subprocess.Popen</code> (no communication server involved here). The user is responsible for managing the launched process and any necessary communication.</li> <li>Isolation: Each environment created by Wetlands is fully isolated, preventing dependency conflicts between different environments or with the main application's environment.</li> </ol>"},{"location":"how_it_works/#under-the-hood","title":"\u2699\ufe0f Under the Hood","text":"<p>Wetlands uses the <code>EnvironmentManager.executeCommands()</code> for different operations (to create environments, install dependencies, etc).  Behind the scenes, this method creates and executes a temporary script (a bash script on Linux and Mac, and a PowerShell script on Windows) which looks like the following:</p> <pre><code># Install Micromamba (only if necessary)\ncd \"/path/to/examples/micromamba\"\necho \"Installing micromamba...\"\ncurl  -Ls https://micro.mamba.pm/api/micromamba/osx-arm64/latest | tar -xvj bin/micromamba\n\n# Initialize Micromamba\ncd \"/path/to/examples/micromamba\"\nexport MAMBA_ROOT_PREFIX=\"/path/to/examples/micromamba\"\neval \"$(bin/micromamba shell hook -s posix)\"\n\n# Create the cellpose environment\ncd \"/Users/amasson/Travail/wetlands/examples\"\nmicromamba --rc-file \"/path/to/examples/micromamba/.mambarc\" create -n cellpose python=3.12.7 -y\n\n# Activate the environment\ncd \"/path/to/examples/\"\nmicromamba activate cellpose\n\n# Install the dependencies\necho \"Installing conda dependencies...\"\nmicromamba --rc-file \"/path/to/examples/micromamba/.mambarc\" install \"cellpose==3.1.0\" -y\n\n# Execute optional custom commands\npython -u example_module.py\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Environment manager</li> <li>Environment</li> <li>Internal environment</li> <li>External environment</li> <li>internal<ul> <li>Command executor</li> <li>Command generator</li> <li>Dependency manager</li> <li>Exceptions</li> <li>Module executor</li> <li>Settings manager</li> </ul> </li> </ul>"},{"location":"reference/wetlands/environment/","title":"Environment","text":""},{"location":"reference/wetlands/environment/#wetlands.environment.Environment","title":"<code>Environment</code>","text":"<p>Methods:</p> Name Description <code>importModule</code> <p>Imports the given module (if necessary) and returns a fake module object</p> <code>install</code> <p>Installs dependencies.</p> <code>launch</code> <p>Launch the environment, only available in ExternalEnvironment. Raises an exception in InternalEnvironment. See <code>InternalEnvironment.launch</code> and <code>ExternalEnvironment.launch</code></p> <code>executeCommands</code> <p>Executes the given commands in this environment.</p> <code>execute</code> <p>Execute the given function in the given module. See <code>ExternalEnvironment.execute</code> and <code>InternalEnvironment.execute</code></p> <code>launched</code> <p>Check if the environment is launched, important in ExternalEnvironment</p> <code>exit</code> <p>Exit the environment</p> Source code in <code>wetlands/environment.py</code> <pre><code>class Environment:\n    modules: dict[str, ModuleType] = {}\n\n    def __init__(self, name: str | None, environmentManager: \"EnvironmentManager\") -&gt; None:\n        self.name = name\n        self.environmentManager = environmentManager\n\n    def _isModFunction(self, mod, func):\n        \"\"\"Checks that func is a function defined in module mod\"\"\"\n        return inspect.isfunction(func) and inspect.getmodule(func) == mod\n\n    def _listFunctions(self, mod):\n        \"\"\"Returns the list of functions defined in module mod\"\"\"\n        return [func.__name__ for func in mod.__dict__.values() if self._isModFunction(mod, func)]\n\n    def _importModule(self, modulePath: Path | str):\n        \"\"\"Imports the given module (if necessary) and adds it to the module map.\"\"\"\n        modulePath = Path(modulePath)\n        module = modulePath.stem\n        if module not in self.modules:\n            sys.path.append(str(modulePath.parent))\n            self.modules[module] = import_module(module)\n        return self.modules[module]\n\n    def importModule(self, modulePath: Path | str) -&gt; Any:\n        \"\"\"Imports the given module (if necessary) and returns a fake module object\n        that contains the same methods of the module which will be executed within the environment.\"\"\"\n        module = self._importModule(modulePath)\n\n        class FakeModule:\n            pass\n\n        for f in self._listFunctions(module):\n\n            def fakeFunction(*args, _wetlands_imported_function=f, **kwargs):\n                return self.execute(modulePath, _wetlands_imported_function, args, kwargs)\n\n            setattr(FakeModule, f, fakeFunction)\n        return FakeModule\n\n    def install(self, dependencies: Dependencies, additionalInstallCommands: Commands = {}) -&gt; list[str]:\n        \"\"\"Installs dependencies.\n        See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n        Args:\n                dependencies: Dependencies to install.\n                additionalInstallCommands: Platform-specific commands during installation.\n        Returns:\n                Output lines of the installation commands.\n        \"\"\"\n        return self.environmentManager.install(self.name, dependencies, additionalInstallCommands)\n\n    @abstractmethod\n    def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n        \"\"\"Launch the environment, only available in [ExternalEnvironment][wetlands.external_environment.ExternalEnvironment]. Raises an exception in [InternalEnvironment][wetlands.internal_environment.InternalEnvironment]. See [`InternalEnvironment.launch`][wetlands.internal_environment.InternalEnvironment.launch] and [`ExternalEnvironment.launch`][wetlands.external_environment.ExternalEnvironment.launch]\"\"\"\n        pass\n\n    def executeCommands(\n        self, commands: Commands, additionalActivateCommands: Commands = {}, popenKwargs: dict[str, Any] = {}\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes the given commands in this environment.\n\n        Args:\n                commands: The commands to execute in the environment.\n                additionalActivateCommands: Platform-specific activation commands.\n                popenKwargs: Keyword arguments for subprocess.Popen(). See [`EnvironmentManager.executeCommands`][wetlands.environment_manager.EnvironmentManager.executeCommands].\n\n        Returns:\n                The launched process.\n        \"\"\"\n        return self.environmentManager.executeCommands(self.name, commands, additionalActivateCommands, popenKwargs)\n\n    @abstractmethod\n    def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Execute the given function in the given module. See [`ExternalEnvironment.execute`][wetlands.external_environment.ExternalEnvironment.execute] and [`InternalEnvironment.execute`][wetlands.internal_environment.InternalEnvironment.execute]\"\"\"\n        pass\n\n    def _exit(self) -&gt; None:\n        \"\"\"Exit the environment, important in ExternalEnvironment\"\"\"\n        pass\n\n    def launched(self) -&gt; bool:\n        \"\"\"Check if the environment is launched, important in ExternalEnvironment\"\"\"\n        return True\n\n    def exit(self) -&gt; None:\n        \"\"\"Exit the environment\"\"\"\n        self._exit()\n        self.environmentManager._removeEnvironment(self)\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.importModule","title":"<code>importModule(modulePath)</code>","text":"<p>Imports the given module (if necessary) and returns a fake module object that contains the same methods of the module which will be executed within the environment.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def importModule(self, modulePath: Path | str) -&gt; Any:\n    \"\"\"Imports the given module (if necessary) and returns a fake module object\n    that contains the same methods of the module which will be executed within the environment.\"\"\"\n    module = self._importModule(modulePath)\n\n    class FakeModule:\n        pass\n\n    for f in self._listFunctions(module):\n\n        def fakeFunction(*args, _wetlands_imported_function=f, **kwargs):\n            return self.execute(modulePath, _wetlands_imported_function, args, kwargs)\n\n        setattr(FakeModule, f, fakeFunction)\n    return FakeModule\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.install","title":"<code>install(dependencies, additionalInstallCommands={})</code>","text":"<p>Installs dependencies. See <code>EnvironmentManager.create</code> for more details on the <code>dependencies</code> and <code>additionalInstallCommands</code> parameters.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <p>Returns:         Output lines of the installation commands.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def install(self, dependencies: Dependencies, additionalInstallCommands: Commands = {}) -&gt; list[str]:\n    \"\"\"Installs dependencies.\n    See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n    Args:\n            dependencies: Dependencies to install.\n            additionalInstallCommands: Platform-specific commands during installation.\n    Returns:\n            Output lines of the installation commands.\n    \"\"\"\n    return self.environmentManager.install(self.name, dependencies, additionalInstallCommands)\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.launch","title":"<code>launch(additionalActivateCommands={}, logOutputInThread=True)</code>  <code>abstractmethod</code>","text":"<p>Launch the environment, only available in ExternalEnvironment. Raises an exception in InternalEnvironment. See <code>InternalEnvironment.launch</code> and <code>ExternalEnvironment.launch</code></p> Source code in <code>wetlands/environment.py</code> <pre><code>@abstractmethod\ndef launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n    \"\"\"Launch the environment, only available in [ExternalEnvironment][wetlands.external_environment.ExternalEnvironment]. Raises an exception in [InternalEnvironment][wetlands.internal_environment.InternalEnvironment]. See [`InternalEnvironment.launch`][wetlands.internal_environment.InternalEnvironment.launch] and [`ExternalEnvironment.launch`][wetlands.external_environment.ExternalEnvironment.launch]\"\"\"\n    pass\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.executeCommands","title":"<code>executeCommands(commands, additionalActivateCommands={}, popenKwargs={})</code>","text":"<p>Executes the given commands in this environment.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>Commands</code> <p>The commands to execute in the environment.</p> required <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>popenKwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen(). See <code>EnvironmentManager.executeCommands</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Popen</code> <p>The launched process.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def executeCommands(\n    self, commands: Commands, additionalActivateCommands: Commands = {}, popenKwargs: dict[str, Any] = {}\n) -&gt; subprocess.Popen:\n    \"\"\"Executes the given commands in this environment.\n\n    Args:\n            commands: The commands to execute in the environment.\n            additionalActivateCommands: Platform-specific activation commands.\n            popenKwargs: Keyword arguments for subprocess.Popen(). See [`EnvironmentManager.executeCommands`][wetlands.environment_manager.EnvironmentManager.executeCommands].\n\n    Returns:\n            The launched process.\n    \"\"\"\n    return self.environmentManager.executeCommands(self.name, commands, additionalActivateCommands, popenKwargs)\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.execute","title":"<code>execute(modulePath, function, args=(), kwargs={})</code>  <code>abstractmethod</code>","text":"<p>Execute the given function in the given module. See <code>ExternalEnvironment.execute</code> and <code>InternalEnvironment.execute</code></p> Source code in <code>wetlands/environment.py</code> <pre><code>@abstractmethod\ndef execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Execute the given function in the given module. See [`ExternalEnvironment.execute`][wetlands.external_environment.ExternalEnvironment.execute] and [`InternalEnvironment.execute`][wetlands.internal_environment.InternalEnvironment.execute]\"\"\"\n    pass\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.launched","title":"<code>launched()</code>","text":"<p>Check if the environment is launched, important in ExternalEnvironment</p> Source code in <code>wetlands/environment.py</code> <pre><code>def launched(self) -&gt; bool:\n    \"\"\"Check if the environment is launched, important in ExternalEnvironment\"\"\"\n    return True\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.exit","title":"<code>exit()</code>","text":"<p>Exit the environment</p> Source code in <code>wetlands/environment.py</code> <pre><code>def exit(self) -&gt; None:\n    \"\"\"Exit the environment\"\"\"\n    self._exit()\n    self.environmentManager._removeEnvironment(self)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/","title":"Environment manager","text":""},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager","title":"<code>EnvironmentManager</code>","text":"<p>Manages Conda environments using micromamba for isolation and dependency management.</p> <p>Attributes:</p> Name Type Description <code>mainEnvironment</code> <code>InternalEnvironment</code> <p>The main conda environment in which wetlands is installed.</p> <code>installedPackages</code> <code>dict[str, dict[str, str]]</code> <p>map of the installed packaged (e.g. {\"pip\": {\"numpy\":2.2.4\"}, \"conda\":{\"icu\":\"75.1\"}})</p> <code>environments</code> <code>dict[str, Environment]</code> <p>map of the environments</p> <code>settingsManager</code> <p>SettingsManager(condaPath)</p> <code>dependencyManager</code> <p>DependencyManager(settingsManager)</p> <code>commandGenerator</code> <p>CommandGenerator(settingsManager, dependencyManager)</p> <code>commandExecutor</code> <p>CommandExecutor()</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the EnvironmentManager with a micromamba path.</p> <code>setCondaPath</code> <p>Updates the micromamba path and loads proxy settings if exists.</p> <code>setProxies</code> <p>Configures proxy settings for Conda operations.</p> <code>environmentExists</code> <p>Checks if a Conda environment exists.</p> <code>create</code> <p>Creates a new Conda environment with specified dependencie or the main environment if dependencies are met in the main environment and forceExternal is False (in which case additional install commands will not be called). Return the existing environment if it was already created.</p> <code>install</code> <p>Installs dependencies.</p> <code>executeCommands</code> <p>Executes the given commands in the given environment.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>class EnvironmentManager:\n    \"\"\"Manages Conda environments using micromamba for isolation and dependency management.\n\n    Attributes:\n            mainEnvironment: The main conda environment in which wetlands is installed.\n            installedPackages: map of the installed packaged (e.g. {\"pip\": {\"numpy\":2.2.4\"}, \"conda\":{\"icu\":\"75.1\"}})\n            environments: map of the environments\n\n            settingsManager: SettingsManager(condaPath)\n            dependencyManager: DependencyManager(settingsManager)\n            commandGenerator: CommandGenerator(settingsManager, dependencyManager)\n            commandExecutor: CommandExecutor()\n    \"\"\"\n\n    mainEnvironment: InternalEnvironment\n    installedPackages: dict[str, dict[str, str]] = {}\n    environments: dict[str, Environment] = {}\n\n    def __init__(\n        self, condaPath: str | Path = Path(\"micromamba\"), mainCondaEnvironmentPath: str | Path | None = None\n    ) -&gt; None:\n        \"\"\"Initializes the EnvironmentManager with a micromamba path.\n\n        Args:\n                condaPath: Path to the micromamba binary. Defaults to \"micromamba\".\n                mainCondaEnvironmentPath: Path of the main conda environment in which wetlands is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment).\n        \"\"\"\n        self.mainEnvironment = InternalEnvironment(mainCondaEnvironmentPath, self)\n        self.settingsManager = SettingsManager(condaPath)\n        self.dependencyManager = DependencyManager(self.settingsManager)\n        self.commandGenerator = CommandGenerator(self.settingsManager, self.dependencyManager)\n        self.commandExecutor = CommandExecutor()\n\n    def setCondaPath(self, condaPath: str | Path) -&gt; None:\n        \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n        Args:\n                condaPath: New path to micromamba binary.\n\n        Side Effects:\n                Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.\n        \"\"\"\n        self.settingsManager.setCondaPath(condaPath)\n\n    def setProxies(self, proxies: dict[str, str]) -&gt; None:\n        \"\"\"Configures proxy settings for Conda operations.\n\n        Args:\n                proxies: Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).\n\n        Side Effects:\n                Updates .mambarc configuration file with proxy settings.\n        \"\"\"\n        self.settingsManager.setProxies(proxies)\n\n    def _removeChannel(self, condaDependency: str) -&gt; str:\n        \"\"\"Removes channel prefix from a Conda dependency string (e.g., \"channel::package\" -&gt; \"package\").\"\"\"\n        return condaDependency.split(\"::\")[1] if \"::\" in condaDependency else condaDependency\n\n    def _checkRequirement(self, dependency: str, packageManager: Literal[\"pip\", \"conda\"]) -&gt; bool:\n        \"\"\"Check if dependency is installed (exists in self.installedPackages[packageManager])\"\"\"\n        if packageManager == \"conda\":\n            dependency = self._removeChannel(dependency)\n        nameVersion = dependency.split(\"==\")\n        return any(\n            [\n                nameVersion[0] == name and (len(nameVersion) == 1 or version.startswith(nameVersion[1]))\n                for name, version in self.installedPackages[packageManager].items()\n            ]\n        )\n\n    def _dependenciesAreInstalled(self, dependencies: Dependencies) -&gt; bool:\n        \"\"\"Verifies if all specified dependencies are installed in the main environment.\n\n        Args:\n                dependencies: Dependencies to check.\n\n        Returns:\n                True if all dependencies are installed, False otherwise.\n        \"\"\"\n\n        if not sys.version.startswith(dependencies.get(\"python\", \"\").replace(\"=\", \"\")):\n            return False\n\n        condaDependencies, condaDependenciesNoDeps, hasCondaDependencies = self.dependencyManager.formatDependencies(\n            \"conda\", dependencies, False, False\n        )\n        pipDependencies, pipDependenciesNoDeps, hasPipDependencies = self.dependencyManager.formatDependencies(\n            \"pip\", dependencies, False, False\n        )\n\n        if hasCondaDependencies:\n            if self.mainEnvironment.name is None:\n                return False\n            elif \"conda\" not in self.installedPackages:\n                commands = self.commandGenerator.getActivateCondaCommands() + [\n                    f\"{self.settingsManager.condaBin} activate {self.mainEnvironment.name}\",\n                    f\"{self.settingsManager.condaBin} list --json\",\n                ]\n                condaList = self.commandExecutor.executeCommandAndGetOutput(commands, log=False)\n\n                json_output = \"\".join(condaList)\n                conda_list = json.loads(json_output)\n\n                for package_info in conda_list:\n                    name = package_info.get(\"name\")\n                    version = package_info.get(\"version\")\n                    if name and version:\n                        if \"conda\" not in self.installedPackages:\n                            self.installedPackages[\"conda\"] = {}\n                        self.installedPackages[\"conda\"][name] = version\n\n            if not all([self._checkRequirement(d, \"conda\") for d in condaDependencies + condaDependenciesNoDeps]):\n                return False\n        if not hasPipDependencies:\n            return True\n\n        if \"pip\" not in self.installedPackages:\n            if self.mainEnvironment.name is not None:\n                commands = self.commandGenerator.getActivateCondaCommands() + [\n                    f\"{self.settingsManager.condaBin} activate {self.mainEnvironment.name}\",\n                    f\"pip freeze --all\",\n                ]\n                output = self.commandExecutor.executeCommandAndGetOutput(commands, log=False)\n                parsedOutput = [o.split(\"==\") for o in output if \"==\" in o]\n                self.installedPackages[\"pip\"] = {name: version for name, version in parsedOutput}\n            else:\n                self.installedPackages[\"pip\"] = {\n                    dist.metadata[\"Name\"]: dist.version for dist in metadata.distributions()\n                }\n\n        return all([self._checkRequirement(d, \"pip\") for d in pipDependencies + pipDependenciesNoDeps])\n\n    def environmentExists(self, environment: str) -&gt; bool:\n        \"\"\"Checks if a Conda environment exists.\n\n        Args:\n                environment: Environment name to check.\n\n        Returns:\n                True if environment exists, False otherwise.\n        \"\"\"\n        condaMeta = Path(self.settingsManager.condaPath) / \"envs\" / environment / \"conda-meta\"\n        return condaMeta.is_dir()\n\n    def create(\n        self,\n        environment: str,\n        dependencies: Dependencies = {},\n        additionalInstallCommands: Commands = {},\n        forceExternal: bool = False,\n    ) -&gt; Environment:\n        \"\"\"Creates a new Conda environment with specified dependencie or the main environment if dependencies are met in the main environment and forceExternal is False (in which case additional install commands will not be called). Return the existing environment if it was already created.\n\n        Args:\n                environment: Name for the new environment. Ignore if dependencies are already installed in the main environment and forceExternal is False.\n                dependencies: Dependencies to install, in the form dict(python=\"3.12.7\", conda=[\"conda-forge::pyimagej==1.5.0\", dict(name=\"openjdk=11\", platforms=[\"osx-64\", \"osx-arm64\", \"win-64\", \"linux-64\"], dependencies=True, optional=False)], pip=[\"numpy==1.26.4\"]).\n                additionalInstallCommands: Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).\n                forceExternal: force create external environment even if dependencies are met in main environment\n\n        Returns:\n                The created environment (InternalEnvironment if dependencies are met in the main environment and not forceExternal, ExternalEnvironment otherwise).\n        \"\"\"\n        if self.environmentExists(environment):\n            if environment not in self.environments:\n                self.environments[environment] = ExternalEnvironment(environment, self)\n            return self.environments[environment]\n        if not forceExternal and self._dependenciesAreInstalled(dependencies):\n            return self.mainEnvironment\n        pythonVersion = dependencies.get(\"python\", \"\").replace(\"=\", \"\")\n        match = re.search(r\"(\\d+)\\.(\\d+)\", pythonVersion)\n        if match and (int(match.group(1)) &lt; 3 or int(match.group(2)) &lt; 9):\n            raise Exception(\"Python version must be greater than 3.8\")\n        pythonRequirement = \" python=\" + (pythonVersion if len(pythonVersion) &gt; 0 else platform.python_version())\n        createEnvCommands = self.commandGenerator.getActivateCondaCommands()\n        createEnvCommands += [f\"{self.settingsManager.condaBinConfig} create -n {environment}{pythonRequirement} -y\"]\n        createEnvCommands += self.dependencyManager.getInstallDependenciesCommands(environment, dependencies)\n        createEnvCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n        self.commandExecutor.executeCommandAndGetOutput(createEnvCommands)\n        self.environments[environment] = ExternalEnvironment(environment, self)\n        return self.environments[environment]\n\n    def install(\n        self, environmentName: str | None, dependencies: Dependencies, additionalInstallCommands: Commands = {}\n    ) -&gt; list[str]:\n        \"\"\"Installs dependencies.\n        See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n        Args:\n                environmentName: The environment to install dependencies.\n                dependencies: Dependencies to install.\n                additionalInstallCommands: Platform-specific commands during installation.\n\n        Returns:\n                Output lines of the installation commands.\n        \"\"\"\n        installCommands = self.commandGenerator.getActivateCondaCommands()\n        installCommands += self.dependencyManager.getInstallDependenciesCommands(environmentName, dependencies)\n        installCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n        return self.commandExecutor.executeCommandAndGetOutput(installCommands)\n\n    def executeCommands(\n        self,\n        environmentName: str | None,\n        commands: Commands,\n        additionalActivateCommands: Commands = {},\n        popenKwargs: dict[str, Any] = {},\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes the given commands in the given environment.\n\n        Args:\n                environmentName: The environment in which to execute commands.\n                commands: The commands to execute in the environment.\n                additionalActivateCommands: Platform-specific activation commands.\n                popenKwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n\n        Returns:\n                The launched process.\n        \"\"\"\n        activateCommands = self.commandGenerator.getActivateEnvironmentCommands(\n            environmentName, additionalActivateCommands\n        )\n        platformCommands = self.commandGenerator.getCommandsForCurrentPlatform(commands)\n        return self.commandExecutor.executeCommands(activateCommands + platformCommands, popenKwargs=popenKwargs)\n\n    def _removeEnvironment(self, environment: Environment) -&gt; None:\n        \"\"\"Remove an environment.\n\n        Args:\n                environment: instance to remove.\n        \"\"\"\n        if environment.name in self.environments:\n            del self.environments[environment.name]\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.__init__","title":"<code>__init__(condaPath=Path('micromamba'), mainCondaEnvironmentPath=None)</code>","text":"<p>Initializes the EnvironmentManager with a micromamba path.</p> <p>Parameters:</p> Name Type Description Default <code>condaPath</code> <code>str | Path</code> <p>Path to the micromamba binary. Defaults to \"micromamba\".</p> <code>Path('micromamba')</code> <code>mainCondaEnvironmentPath</code> <code>str | Path | None</code> <p>Path of the main conda environment in which wetlands is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment).</p> <code>None</code> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def __init__(\n    self, condaPath: str | Path = Path(\"micromamba\"), mainCondaEnvironmentPath: str | Path | None = None\n) -&gt; None:\n    \"\"\"Initializes the EnvironmentManager with a micromamba path.\n\n    Args:\n            condaPath: Path to the micromamba binary. Defaults to \"micromamba\".\n            mainCondaEnvironmentPath: Path of the main conda environment in which wetlands is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment).\n    \"\"\"\n    self.mainEnvironment = InternalEnvironment(mainCondaEnvironmentPath, self)\n    self.settingsManager = SettingsManager(condaPath)\n    self.dependencyManager = DependencyManager(self.settingsManager)\n    self.commandGenerator = CommandGenerator(self.settingsManager, self.dependencyManager)\n    self.commandExecutor = CommandExecutor()\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.setCondaPath","title":"<code>setCondaPath(condaPath)</code>","text":"<p>Updates the micromamba path and loads proxy settings if exists.</p> <p>Parameters:</p> Name Type Description Default <code>condaPath</code> <code>str | Path</code> <p>New path to micromamba binary.</p> required Side Effects <p>Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def setCondaPath(self, condaPath: str | Path) -&gt; None:\n    \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n    Args:\n            condaPath: New path to micromamba binary.\n\n    Side Effects:\n            Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.\n    \"\"\"\n    self.settingsManager.setCondaPath(condaPath)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.setProxies","title":"<code>setProxies(proxies)</code>","text":"<p>Configures proxy settings for Conda operations.</p> <p>Parameters:</p> Name Type Description Default <code>proxies</code> <code>dict[str, str]</code> <p>Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).</p> required Side Effects <p>Updates .mambarc configuration file with proxy settings.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def setProxies(self, proxies: dict[str, str]) -&gt; None:\n    \"\"\"Configures proxy settings for Conda operations.\n\n    Args:\n            proxies: Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).\n\n    Side Effects:\n            Updates .mambarc configuration file with proxy settings.\n    \"\"\"\n    self.settingsManager.setProxies(proxies)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.environmentExists","title":"<code>environmentExists(environment)</code>","text":"<p>Checks if a Conda environment exists.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>str</code> <p>Environment name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if environment exists, False otherwise.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def environmentExists(self, environment: str) -&gt; bool:\n    \"\"\"Checks if a Conda environment exists.\n\n    Args:\n            environment: Environment name to check.\n\n    Returns:\n            True if environment exists, False otherwise.\n    \"\"\"\n    condaMeta = Path(self.settingsManager.condaPath) / \"envs\" / environment / \"conda-meta\"\n    return condaMeta.is_dir()\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.create","title":"<code>create(environment, dependencies={}, additionalInstallCommands={}, forceExternal=False)</code>","text":"<p>Creates a new Conda environment with specified dependencie or the main environment if dependencies are met in the main environment and forceExternal is False (in which case additional install commands will not be called). Return the existing environment if it was already created.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>str</code> <p>Name for the new environment. Ignore if dependencies are already installed in the main environment and forceExternal is False.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install, in the form dict(python=\"3.12.7\", conda=[\"conda-forge::pyimagej==1.5.0\", dict(name=\"openjdk=11\", platforms=[\"osx-64\", \"osx-arm64\", \"win-64\", \"linux-64\"], dependencies=True, optional=False)], pip=[\"numpy==1.26.4\"]).</p> <code>{}</code> <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).</p> <code>{}</code> <code>forceExternal</code> <code>bool</code> <p>force create external environment even if dependencies are met in main environment</p> <code>False</code> <p>Returns:</p> Type Description <code>Environment</code> <p>The created environment (InternalEnvironment if dependencies are met in the main environment and not forceExternal, ExternalEnvironment otherwise).</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def create(\n    self,\n    environment: str,\n    dependencies: Dependencies = {},\n    additionalInstallCommands: Commands = {},\n    forceExternal: bool = False,\n) -&gt; Environment:\n    \"\"\"Creates a new Conda environment with specified dependencie or the main environment if dependencies are met in the main environment and forceExternal is False (in which case additional install commands will not be called). Return the existing environment if it was already created.\n\n    Args:\n            environment: Name for the new environment. Ignore if dependencies are already installed in the main environment and forceExternal is False.\n            dependencies: Dependencies to install, in the form dict(python=\"3.12.7\", conda=[\"conda-forge::pyimagej==1.5.0\", dict(name=\"openjdk=11\", platforms=[\"osx-64\", \"osx-arm64\", \"win-64\", \"linux-64\"], dependencies=True, optional=False)], pip=[\"numpy==1.26.4\"]).\n            additionalInstallCommands: Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).\n            forceExternal: force create external environment even if dependencies are met in main environment\n\n    Returns:\n            The created environment (InternalEnvironment if dependencies are met in the main environment and not forceExternal, ExternalEnvironment otherwise).\n    \"\"\"\n    if self.environmentExists(environment):\n        if environment not in self.environments:\n            self.environments[environment] = ExternalEnvironment(environment, self)\n        return self.environments[environment]\n    if not forceExternal and self._dependenciesAreInstalled(dependencies):\n        return self.mainEnvironment\n    pythonVersion = dependencies.get(\"python\", \"\").replace(\"=\", \"\")\n    match = re.search(r\"(\\d+)\\.(\\d+)\", pythonVersion)\n    if match and (int(match.group(1)) &lt; 3 or int(match.group(2)) &lt; 9):\n        raise Exception(\"Python version must be greater than 3.8\")\n    pythonRequirement = \" python=\" + (pythonVersion if len(pythonVersion) &gt; 0 else platform.python_version())\n    createEnvCommands = self.commandGenerator.getActivateCondaCommands()\n    createEnvCommands += [f\"{self.settingsManager.condaBinConfig} create -n {environment}{pythonRequirement} -y\"]\n    createEnvCommands += self.dependencyManager.getInstallDependenciesCommands(environment, dependencies)\n    createEnvCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n    self.commandExecutor.executeCommandAndGetOutput(createEnvCommands)\n    self.environments[environment] = ExternalEnvironment(environment, self)\n    return self.environments[environment]\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.install","title":"<code>install(environmentName, dependencies, additionalInstallCommands={})</code>","text":"<p>Installs dependencies. See <code>EnvironmentManager.create</code> for more details on the <code>dependencies</code> and <code>additionalInstallCommands</code> parameters.</p> <p>Parameters:</p> Name Type Description Default <code>environmentName</code> <code>str | None</code> <p>The environment to install dependencies.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Output lines of the installation commands.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def install(\n    self, environmentName: str | None, dependencies: Dependencies, additionalInstallCommands: Commands = {}\n) -&gt; list[str]:\n    \"\"\"Installs dependencies.\n    See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n    Args:\n            environmentName: The environment to install dependencies.\n            dependencies: Dependencies to install.\n            additionalInstallCommands: Platform-specific commands during installation.\n\n    Returns:\n            Output lines of the installation commands.\n    \"\"\"\n    installCommands = self.commandGenerator.getActivateCondaCommands()\n    installCommands += self.dependencyManager.getInstallDependenciesCommands(environmentName, dependencies)\n    installCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n    return self.commandExecutor.executeCommandAndGetOutput(installCommands)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.executeCommands","title":"<code>executeCommands(environmentName, commands, additionalActivateCommands={}, popenKwargs={})</code>","text":"<p>Executes the given commands in the given environment.</p> <p>Parameters:</p> Name Type Description Default <code>environmentName</code> <code>str | None</code> <p>The environment in which to execute commands.</p> required <code>commands</code> <code>Commands</code> <p>The commands to execute in the environment.</p> required <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>popenKwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen() (see Popen documentation). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Popen</code> <p>The launched process.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def executeCommands(\n    self,\n    environmentName: str | None,\n    commands: Commands,\n    additionalActivateCommands: Commands = {},\n    popenKwargs: dict[str, Any] = {},\n) -&gt; subprocess.Popen:\n    \"\"\"Executes the given commands in the given environment.\n\n    Args:\n            environmentName: The environment in which to execute commands.\n            commands: The commands to execute in the environment.\n            additionalActivateCommands: Platform-specific activation commands.\n            popenKwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n\n    Returns:\n            The launched process.\n    \"\"\"\n    activateCommands = self.commandGenerator.getActivateEnvironmentCommands(\n        environmentName, additionalActivateCommands\n    )\n    platformCommands = self.commandGenerator.getCommandsForCurrentPlatform(commands)\n    return self.commandExecutor.executeCommands(activateCommands + platformCommands, popenKwargs=popenKwargs)\n</code></pre>"},{"location":"reference/wetlands/external_environment/","title":"External environment","text":""},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment","title":"<code>ExternalEnvironment</code>","text":"<p>               Bases: <code>Environment</code></p> <p>Methods:</p> Name Description <code>logOutput</code> <p>Logs output from the subprocess.</p> <code>launch</code> <p>Launches a server listening for orders in the environment.</p> <code>execute</code> <p>Executes a function in the given module and return the result.</p> <code>launched</code> <p>Return true if the environment server process is launched and the connection is open.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>class ExternalEnvironment(Environment):\n    port: int | None = None\n    process: subprocess.Popen | None = None\n    connection: Connection | None = None\n\n    def __init__(self, name: str, environmentManager: \"EnvironmentManager\") -&gt; None:\n        super().__init__(name, environmentManager)\n\n    def logOutput(self) -&gt; None:\n        \"\"\"Logs output from the subprocess.\"\"\"\n        if self.process is None or self.process.stdout is None or self.process.stdout.readline is None:\n            return\n        try:\n            for line in iter(self.process.stdout.readline, \"\"):  # Use iter to avoid buffering issues:\n                # iter(callable, sentinel) repeatedly calls callable (process.stdout.readline) until it returns the sentinel value (\"\", an empty string).\n                # Since readline() is called directly in each iteration, it immediately processes available output instead of accumulating it in a buffer.\n                # This effectively forces line-by-line reading in real-time rather than waiting for the subprocess to fill its buffer.\n                logger.info(line.strip())\n        except Exception as e:\n            logger.error(f\"Exception in logging thread: {e}\")\n        return\n\n    def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n        \"\"\"Launches a server listening for orders in the environment.\n\n        Args:\n                additionalActivateCommands: Platform-specific activation commands.\n                logOutputInThread: Logs the process output in a separate thread.\n        \"\"\"\n\n        moduleExecutorPath = Path(__file__).parent.resolve() / \"_internal\" / \"module_executor.py\"\n\n        commands = self.environmentManager.commandGenerator.getActivateEnvironmentCommands(\n            self.name, additionalActivateCommands\n        )\n        commands += [f'python -u \"{moduleExecutorPath}\" {self.name}']\n        self.process = self.executeCommands(commands)\n\n        if self.process.stdout is not None:\n            try:\n                for line in self.process.stdout:\n                    logger.info(line.strip())\n                    if line.strip().startswith(\"Listening port \"):\n                        self.port = int(line.strip().replace(\"Listening port \", \"\"))\n                        break\n            except Exception as e:\n                self.process.stdout.close()\n                raise e\n        if self.process.poll() is not None:\n            if self.process.stdout is not None:\n                self.process.stdout.close()\n            raise Exception(f\"Process exited with return code {self.process.returncode}.\")\n        if self.port is None:\n            raise Exception(f\"Could not find the server port.\")\n        self.connection = Client((\"localhost\", self.port))\n\n        if logOutputInThread:\n            threading.Thread(target=self.logOutput, args=[]).start()\n\n    def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Executes a function in the given module and return the result.\n\n        Args:\n                modulePath: the path to the module to import\n                function: the name of the function to execute\n                args: the argument list for the function\n                kwargs: the keyword arguments for the function\n\n        Returns:\n                The result of the function if it is defined and the connection is opened ; None otherwise.\n        Raises:\n            OSError when raised by the communication.\n        \"\"\"\n        connection = self.connection\n        if connection is None or connection.closed:\n            logger.warning(f\"Connection not ready. Skipping execute {modulePath}.{function}({args})\")\n            return None\n        try:\n            connection.send(dict(action=\"execute\", modulePath=modulePath, function=function, args=args, kwargs=kwargs))\n            while message := connection.recv():\n                if message[\"action\"] == \"execution finished\":\n                    logger.info(\"execution finished\")\n                    return message.get(\"result\")\n                elif message[\"action\"] == \"error\":\n                    raise ExecutionException(message)\n                else:\n                    logger.warning(f\"Got an unexpected message: {message}\")\n        # If the connection was closed (subprocess killed): catch and ignore the exception, otherwise: raise it\n        except EOFError:\n            print(\"Connection closed gracefully by the peer.\")\n        except BrokenPipeError as e:\n            logger.error(f\"Broken pipe. The peer process might have terminated. Exception: {e}.\")\n        except OSError as e:\n            if e.errno == 9:  # Bad file descriptor\n                logger.error(\"Connection closed abruptly by the peer.\")\n            else:\n                logger.error(f\"Unexpected OSError: {e}\")\n                raise e\n        return None\n\n    def launched(self) -&gt; bool:\n        \"\"\"Return true if the environment server process is launched and the connection is open.\"\"\"\n        return (\n            self.process is not None\n            and self.process.poll() is None\n            and self.connection is not None\n            and not self.connection.closed\n            and self.connection.writable\n            and self.connection.readable\n        )\n\n    def _exit(self) -&gt; None:\n        \"\"\"Close the connection to the environment and kills the process.\"\"\"\n        if self.connection is not None:\n            try:\n                self.connection.send(dict(action=\"exit\"))\n            except OSError as e:\n                if e.args[0] == \"handle is closed\":\n                    pass\n            self.connection.close()\n\n        CommandExecutor.killProcess(self.process)\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.logOutput","title":"<code>logOutput()</code>","text":"<p>Logs output from the subprocess.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>def logOutput(self) -&gt; None:\n    \"\"\"Logs output from the subprocess.\"\"\"\n    if self.process is None or self.process.stdout is None or self.process.stdout.readline is None:\n        return\n    try:\n        for line in iter(self.process.stdout.readline, \"\"):  # Use iter to avoid buffering issues:\n            # iter(callable, sentinel) repeatedly calls callable (process.stdout.readline) until it returns the sentinel value (\"\", an empty string).\n            # Since readline() is called directly in each iteration, it immediately processes available output instead of accumulating it in a buffer.\n            # This effectively forces line-by-line reading in real-time rather than waiting for the subprocess to fill its buffer.\n            logger.info(line.strip())\n    except Exception as e:\n        logger.error(f\"Exception in logging thread: {e}\")\n    return\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.launch","title":"<code>launch(additionalActivateCommands={}, logOutputInThread=True)</code>","text":"<p>Launches a server listening for orders in the environment.</p> <p>Parameters:</p> Name Type Description Default <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>logOutputInThread</code> <code>bool</code> <p>Logs the process output in a separate thread.</p> <code>True</code> Source code in <code>wetlands/external_environment.py</code> <pre><code>def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n    \"\"\"Launches a server listening for orders in the environment.\n\n    Args:\n            additionalActivateCommands: Platform-specific activation commands.\n            logOutputInThread: Logs the process output in a separate thread.\n    \"\"\"\n\n    moduleExecutorPath = Path(__file__).parent.resolve() / \"_internal\" / \"module_executor.py\"\n\n    commands = self.environmentManager.commandGenerator.getActivateEnvironmentCommands(\n        self.name, additionalActivateCommands\n    )\n    commands += [f'python -u \"{moduleExecutorPath}\" {self.name}']\n    self.process = self.executeCommands(commands)\n\n    if self.process.stdout is not None:\n        try:\n            for line in self.process.stdout:\n                logger.info(line.strip())\n                if line.strip().startswith(\"Listening port \"):\n                    self.port = int(line.strip().replace(\"Listening port \", \"\"))\n                    break\n        except Exception as e:\n            self.process.stdout.close()\n            raise e\n    if self.process.poll() is not None:\n        if self.process.stdout is not None:\n            self.process.stdout.close()\n        raise Exception(f\"Process exited with return code {self.process.returncode}.\")\n    if self.port is None:\n        raise Exception(f\"Could not find the server port.\")\n    self.connection = Client((\"localhost\", self.port))\n\n    if logOutputInThread:\n        threading.Thread(target=self.logOutput, args=[]).start()\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.execute","title":"<code>execute(modulePath, function, args=(), kwargs={})</code>","text":"<p>Executes a function in the given module and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>modulePath</code> <code>str | Path</code> <p>the path to the module to import</p> required <code>function</code> <code>str</code> <p>the name of the function to execute</p> required <code>args</code> <code>tuple</code> <p>the argument list for the function</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>the keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the function if it is defined and the connection is opened ; None otherwise.</p> <p>Raises:     OSError when raised by the communication.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Executes a function in the given module and return the result.\n\n    Args:\n            modulePath: the path to the module to import\n            function: the name of the function to execute\n            args: the argument list for the function\n            kwargs: the keyword arguments for the function\n\n    Returns:\n            The result of the function if it is defined and the connection is opened ; None otherwise.\n    Raises:\n        OSError when raised by the communication.\n    \"\"\"\n    connection = self.connection\n    if connection is None or connection.closed:\n        logger.warning(f\"Connection not ready. Skipping execute {modulePath}.{function}({args})\")\n        return None\n    try:\n        connection.send(dict(action=\"execute\", modulePath=modulePath, function=function, args=args, kwargs=kwargs))\n        while message := connection.recv():\n            if message[\"action\"] == \"execution finished\":\n                logger.info(\"execution finished\")\n                return message.get(\"result\")\n            elif message[\"action\"] == \"error\":\n                raise ExecutionException(message)\n            else:\n                logger.warning(f\"Got an unexpected message: {message}\")\n    # If the connection was closed (subprocess killed): catch and ignore the exception, otherwise: raise it\n    except EOFError:\n        print(\"Connection closed gracefully by the peer.\")\n    except BrokenPipeError as e:\n        logger.error(f\"Broken pipe. The peer process might have terminated. Exception: {e}.\")\n    except OSError as e:\n        if e.errno == 9:  # Bad file descriptor\n            logger.error(\"Connection closed abruptly by the peer.\")\n        else:\n            logger.error(f\"Unexpected OSError: {e}\")\n            raise e\n    return None\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.launched","title":"<code>launched()</code>","text":"<p>Return true if the environment server process is launched and the connection is open.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>def launched(self) -&gt; bool:\n    \"\"\"Return true if the environment server process is launched and the connection is open.\"\"\"\n    return (\n        self.process is not None\n        and self.process.poll() is None\n        and self.connection is not None\n        and not self.connection.closed\n        and self.connection.writable\n        and self.connection.readable\n    )\n</code></pre>"},{"location":"reference/wetlands/internal_environment/","title":"Internal environment","text":""},{"location":"reference/wetlands/internal_environment/#wetlands.internal_environment.InternalEnvironment","title":"<code>InternalEnvironment</code>","text":"<p>               Bases: <code>Environment</code></p> <p>Methods:</p> Name Description <code>launch</code> <p>Raise an exception. See <code>Environment.launch</code> and <code>ExternalEnvironment.launch</code></p> <code>execute</code> <p>Executes a function in the given module</p> Source code in <code>wetlands/internal_environment.py</code> <pre><code>class InternalEnvironment(Environment):\n    def __init__(self, name: Path | str | None, environmentManager: \"EnvironmentManager\") -&gt; None:\n        super().__init__(self._addTrailingSlash(name), environmentManager)\n\n    def _addTrailingSlash(self, path: Path | str | None) -&gt; str | None:\n        # https://stackoverflow.com/questions/47572165/whats-the-best-way-to-add-a-trailing-slash-to-a-pathlib-directory\n        if path is None:\n            return path\n        return str(Path(path) / \"_\")[:-1]\n\n    def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n        \"\"\"Raise an exception. See [`Environment.launch`][wetlands.environment.Environment.launch] and [`ExternalEnvironment.launch`][wetlands.external_environment.ExternalEnvironment.launch]\"\"\"\n        raise Exception(\"Cannot launch the main environment.\")\n\n    def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Executes a function in the given module\n\n        Args:\n                modulePath: the path to the module to import\n                function: the name of the function to execute\n                args: the argument list for the function\n                kwargs: the keyword arguments for the function\n\n        Returns:\n                The result of the function\n        \"\"\"\n        module = self._importModule(modulePath)\n        if not self._isModFunction(module, function):\n            raise Exception(f\"Module {modulePath} has no function {function}.\")\n        return getattr(module, function)(*args)\n</code></pre>"},{"location":"reference/wetlands/internal_environment/#wetlands.internal_environment.InternalEnvironment.launch","title":"<code>launch(additionalActivateCommands={}, logOutputInThread=True)</code>","text":"<p>Raise an exception. See <code>Environment.launch</code> and <code>ExternalEnvironment.launch</code></p> Source code in <code>wetlands/internal_environment.py</code> <pre><code>def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n    \"\"\"Raise an exception. See [`Environment.launch`][wetlands.environment.Environment.launch] and [`ExternalEnvironment.launch`][wetlands.external_environment.ExternalEnvironment.launch]\"\"\"\n    raise Exception(\"Cannot launch the main environment.\")\n</code></pre>"},{"location":"reference/wetlands/internal_environment/#wetlands.internal_environment.InternalEnvironment.execute","title":"<code>execute(modulePath, function, args=(), kwargs={})</code>","text":"<p>Executes a function in the given module</p> <p>Parameters:</p> Name Type Description Default <code>modulePath</code> <code>str | Path</code> <p>the path to the module to import</p> required <code>function</code> <code>str</code> <p>the name of the function to execute</p> required <code>args</code> <code>tuple</code> <p>the argument list for the function</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>the keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the function</p> Source code in <code>wetlands/internal_environment.py</code> <pre><code>def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Executes a function in the given module\n\n    Args:\n            modulePath: the path to the module to import\n            function: the name of the function to execute\n            args: the argument list for the function\n            kwargs: the keyword arguments for the function\n\n    Returns:\n            The result of the function\n    \"\"\"\n    module = self._importModule(modulePath)\n    if not self._isModFunction(module, function):\n        raise Exception(f\"Module {modulePath} has no function {function}.\")\n    return getattr(module, function)(*args)\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/","title":"Command executor","text":""},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor","title":"<code>CommandExecutor</code>","text":"<p>Handles execution of shell commands with error checking and logging.</p> <p>Methods:</p> Name Description <code>killProcess</code> <p>Terminates the process and its children</p> <code>getOutput</code> <p>Captures and processes output from a subprocess.</p> <code>executeCommands</code> <p>Executes shell commands in a subprocess.</p> <code>executeCommandAndGetOutput</code> <p>Executes commands and captures their output. See <code>CommandExecutor.executeCommands</code> for more details on the arguments.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>class CommandExecutor:\n    \"\"\"Handles execution of shell commands with error checking and logging.\"\"\"\n\n    @staticmethod\n    def killProcess(process) -&gt; None:\n        \"\"\"Terminates the process and its children\"\"\"\n        if process is None:\n            return\n        parent = psutil.Process(process.pid)\n        for child in parent.children(recursive=True):  # Get all child processes\n            if child.is_running():\n                child.kill()\n        if parent.is_running():\n            parent.kill()\n\n    def _isWindows(self) -&gt; bool:\n        \"\"\"Checks if the current OS is Windows.\"\"\"\n        return platform.system() == \"Windows\"\n\n    def _insertCommandErrorChecks(self, commands: list[str]) -&gt; list[str]:\n        \"\"\"Inserts error checking commands after each shell command.\n\n        Args:\n                commands: List of original shell commands.\n\n        Returns:\n                Augmented command list with error checking logic.\n        \"\"\"\n        commandsWithChecks = []\n        errorMessage = \"Errors encountered during execution. Exited with status:\"\n        windowsChecks = [\"\", \"if (! $?) { exit 1 } \"]\n        posixChecks = [\n            \"\",\n            \"return_status=$?\",\n            \"if [ $return_status -ne 0 ]\",\n            \"then\",\n            f'    echo \"{errorMessage} $return_status\"',\n            \"    exit 1\",\n            \"fi\",\n            \"\",\n        ]\n        checks = windowsChecks if self._isWindows() else posixChecks\n        for command in commands:\n            commandsWithChecks.append(command)\n            commandsWithChecks += checks\n        return commandsWithChecks\n\n    def _commandsExcerpt(self, commands: list[str]) -&gt; str:\n        \"\"\"Returns the command list as a string but cap the length at 150 characters\n        (for example to be able to display it in a dialog window).\"\"\"\n        if commands is None or len(commands) == 0:\n            return \"\"\n        prefix: str = \"[...] \" if len(str(commands)) &gt; 150 else \"\"\n        return prefix + str(commands)[-150:]\n\n    def getOutput(\n        self,\n        process: subprocess.Popen,\n        commands: list[str],\n        log: bool = True,\n        strip: bool = True,\n    ) -&gt; list[str]:\n        \"\"\"Captures and processes output from a subprocess.\n\n        Args:\n                process: Subprocess to monitor.\n                commands: Commands that were executed (for error messages).\n                log: Whether to log output lines.\n                strip: Whether to strip whitespace from output lines.\n\n        Returns:\n                Output lines.\n\n        Raises:\n                Exception: If CondaSystemExit is detected or non-zero exit code.\n        \"\"\"\n        outputs = []\n        if process.stdout is not None:\n            for line in process.stdout:\n                if strip:\n                    line = line.strip()\n                if log:\n                    logger.info(line)\n                if \"CondaSystemExit\" in line:  # Sometime conda exists with a CondaSystemExit and a return code 0\n                    # we want to stop our script when this happens (and not run the later commands)\n                    self.killProcess(process)\n                    raise Exception(f'The execution of the commands \"{self._commandsExcerpt(commands)}\" failed.')\n                outputs.append(line)\n        process.wait()\n        if process.returncode != 0:\n            raise Exception(f'The execution of the commands \"{self._commandsExcerpt(commands)}\" failed.')\n        return outputs\n\n    def executeCommands(\n        self,\n        commands: list[str],\n        exitIfCommandError: bool = True,\n        popenKwargs: dict[str, Any] = {},\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes shell commands in a subprocess.\n\n        Args:\n                commands: List of shell commands to execute.\n                exitIfCommandError: Whether to insert error checking after each command to make sure the whole command chain stops if an error occurs (otherwise the script will be executed entirely even when one command fails at the beginning).\n                popenKwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n\n        Returns:\n                Subprocess handle for the executed commands.\n        \"\"\"\n        logger.debug(f\"Execute commands:\\n\\n\\t\\t{'\\n\\t\\t'.join(commands)}\\n\")\n        with tempfile.NamedTemporaryFile(suffix=\".ps1\" if self._isWindows() else \".sh\", mode=\"w\", delete=False) as tmp:\n            if exitIfCommandError:\n                commands = self._insertCommandErrorChecks(commands)\n            tmp.write(\"\\n\".join(commands))\n            tmp.flush()\n            tmp.close()\n            executeFile = (\n                [\n                    \"powershell\",\n                    \"-WindowStyle\",\n                    \"Hidden\",\n                    \"-NoProfile\",\n                    \"-ExecutionPolicy\",\n                    \"ByPass\",\n                    \"-File\",\n                    tmp.name,\n                ]\n                if self._isWindows()\n                else [\"/bin/bash\", tmp.name]\n            )\n            if not self._isWindows():\n                subprocess.run([\"chmod\", \"u+x\", tmp.name])\n            logger.debug(f\"Script file: {tmp.name}\")\n            defaultPopenKwargs = {\n                \"stdout\": subprocess.PIPE,\n                \"stderr\": subprocess.STDOUT,  # Merge stderr and stdout to handle all them with a single loop\n                \"stdin\": subprocess.DEVNULL,  # Prevent the command to wait for input: instead we want to stop if this happens\n                \"encoding\": \"utf-8\",\n                \"errors\": \"replace\",  # Determines how encoding and decoding errors should be handled: replaces invalid characters with a placeholder (e.g., ? in ASCII).\n                \"bufsize\": 1,  # 1 means line buffered\n            }\n            process = subprocess.Popen(executeFile, **(defaultPopenKwargs | popenKwargs))\n            return process\n\n    def executeCommandAndGetOutput(\n        self,\n        commands: list[str],\n        exitIfCommandError: bool = True,\n        log: bool = True,\n        popenKwargs: dict[str, Any] = {},\n    ) -&gt; list[str]:\n        \"\"\"Executes commands and captures their output. See [`CommandExecutor.executeCommands`][wetlands._internal.command_executor.CommandExecutor.executeCommands] for more details on the arguments.\n\n        Args:\n                commands: Shell commands to execute.\n                exitIfCommandError: Whether to insert error checking.\n                log: Enable logging of command output.\n                popenKwargs: Keyword arguments for subprocess.Popen().\n\n        Returns:\n                Output lines.\n        \"\"\"\n        rawCommands = commands.copy()\n        process = self.executeCommands(commands, exitIfCommandError, popenKwargs)\n        with process:\n            return self.getOutput(process, rawCommands, log=log)\n        return\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.killProcess","title":"<code>killProcess(process)</code>  <code>staticmethod</code>","text":"<p>Terminates the process and its children</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>@staticmethod\ndef killProcess(process) -&gt; None:\n    \"\"\"Terminates the process and its children\"\"\"\n    if process is None:\n        return\n    parent = psutil.Process(process.pid)\n    for child in parent.children(recursive=True):  # Get all child processes\n        if child.is_running():\n            child.kill()\n    if parent.is_running():\n        parent.kill()\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.getOutput","title":"<code>getOutput(process, commands, log=True, strip=True)</code>","text":"<p>Captures and processes output from a subprocess.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Popen</code> <p>Subprocess to monitor.</p> required <code>commands</code> <code>list[str]</code> <p>Commands that were executed (for error messages).</p> required <code>log</code> <code>bool</code> <p>Whether to log output lines.</p> <code>True</code> <code>strip</code> <code>bool</code> <p>Whether to strip whitespace from output lines.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Output lines.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If CondaSystemExit is detected or non-zero exit code.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def getOutput(\n    self,\n    process: subprocess.Popen,\n    commands: list[str],\n    log: bool = True,\n    strip: bool = True,\n) -&gt; list[str]:\n    \"\"\"Captures and processes output from a subprocess.\n\n    Args:\n            process: Subprocess to monitor.\n            commands: Commands that were executed (for error messages).\n            log: Whether to log output lines.\n            strip: Whether to strip whitespace from output lines.\n\n    Returns:\n            Output lines.\n\n    Raises:\n            Exception: If CondaSystemExit is detected or non-zero exit code.\n    \"\"\"\n    outputs = []\n    if process.stdout is not None:\n        for line in process.stdout:\n            if strip:\n                line = line.strip()\n            if log:\n                logger.info(line)\n            if \"CondaSystemExit\" in line:  # Sometime conda exists with a CondaSystemExit and a return code 0\n                # we want to stop our script when this happens (and not run the later commands)\n                self.killProcess(process)\n                raise Exception(f'The execution of the commands \"{self._commandsExcerpt(commands)}\" failed.')\n            outputs.append(line)\n    process.wait()\n    if process.returncode != 0:\n        raise Exception(f'The execution of the commands \"{self._commandsExcerpt(commands)}\" failed.')\n    return outputs\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.executeCommands","title":"<code>executeCommands(commands, exitIfCommandError=True, popenKwargs={})</code>","text":"<p>Executes shell commands in a subprocess.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>list[str]</code> <p>List of shell commands to execute.</p> required <code>exitIfCommandError</code> <code>bool</code> <p>Whether to insert error checking after each command to make sure the whole command chain stops if an error occurs (otherwise the script will be executed entirely even when one command fails at the beginning).</p> <code>True</code> <code>popenKwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen() (see Popen documentation). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Popen</code> <p>Subprocess handle for the executed commands.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def executeCommands(\n    self,\n    commands: list[str],\n    exitIfCommandError: bool = True,\n    popenKwargs: dict[str, Any] = {},\n) -&gt; subprocess.Popen:\n    \"\"\"Executes shell commands in a subprocess.\n\n    Args:\n            commands: List of shell commands to execute.\n            exitIfCommandError: Whether to insert error checking after each command to make sure the whole command chain stops if an error occurs (otherwise the script will be executed entirely even when one command fails at the beginning).\n            popenKwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n\n    Returns:\n            Subprocess handle for the executed commands.\n    \"\"\"\n    logger.debug(f\"Execute commands:\\n\\n\\t\\t{'\\n\\t\\t'.join(commands)}\\n\")\n    with tempfile.NamedTemporaryFile(suffix=\".ps1\" if self._isWindows() else \".sh\", mode=\"w\", delete=False) as tmp:\n        if exitIfCommandError:\n            commands = self._insertCommandErrorChecks(commands)\n        tmp.write(\"\\n\".join(commands))\n        tmp.flush()\n        tmp.close()\n        executeFile = (\n            [\n                \"powershell\",\n                \"-WindowStyle\",\n                \"Hidden\",\n                \"-NoProfile\",\n                \"-ExecutionPolicy\",\n                \"ByPass\",\n                \"-File\",\n                tmp.name,\n            ]\n            if self._isWindows()\n            else [\"/bin/bash\", tmp.name]\n        )\n        if not self._isWindows():\n            subprocess.run([\"chmod\", \"u+x\", tmp.name])\n        logger.debug(f\"Script file: {tmp.name}\")\n        defaultPopenKwargs = {\n            \"stdout\": subprocess.PIPE,\n            \"stderr\": subprocess.STDOUT,  # Merge stderr and stdout to handle all them with a single loop\n            \"stdin\": subprocess.DEVNULL,  # Prevent the command to wait for input: instead we want to stop if this happens\n            \"encoding\": \"utf-8\",\n            \"errors\": \"replace\",  # Determines how encoding and decoding errors should be handled: replaces invalid characters with a placeholder (e.g., ? in ASCII).\n            \"bufsize\": 1,  # 1 means line buffered\n        }\n        process = subprocess.Popen(executeFile, **(defaultPopenKwargs | popenKwargs))\n        return process\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.executeCommandAndGetOutput","title":"<code>executeCommandAndGetOutput(commands, exitIfCommandError=True, log=True, popenKwargs={})</code>","text":"<p>Executes commands and captures their output. See <code>CommandExecutor.executeCommands</code> for more details on the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>list[str]</code> <p>Shell commands to execute.</p> required <code>exitIfCommandError</code> <code>bool</code> <p>Whether to insert error checking.</p> <code>True</code> <code>log</code> <code>bool</code> <p>Enable logging of command output.</p> <code>True</code> <code>popenKwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen().</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Output lines.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def executeCommandAndGetOutput(\n    self,\n    commands: list[str],\n    exitIfCommandError: bool = True,\n    log: bool = True,\n    popenKwargs: dict[str, Any] = {},\n) -&gt; list[str]:\n    \"\"\"Executes commands and captures their output. See [`CommandExecutor.executeCommands`][wetlands._internal.command_executor.CommandExecutor.executeCommands] for more details on the arguments.\n\n    Args:\n            commands: Shell commands to execute.\n            exitIfCommandError: Whether to insert error checking.\n            log: Enable logging of command output.\n            popenKwargs: Keyword arguments for subprocess.Popen().\n\n    Returns:\n            Output lines.\n    \"\"\"\n    rawCommands = commands.copy()\n    process = self.executeCommands(commands, exitIfCommandError, popenKwargs)\n    with process:\n        return self.getOutput(process, rawCommands, log=log)\n    return\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/","title":"Command generator","text":""},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator","title":"<code>CommandGenerator</code>","text":"<p>Generate Conda commands.</p> <p>Methods:</p> Name Description <code>getShellHookCommands</code> <p>Generates shell commands for Conda initialization.</p> <code>createMambaConfigFile</code> <p>Create Mamba config file .mambarc in condaPath, with nodefaults and conda-forge channels.</p> <code>getPlatformCommonName</code> <p>Gets common platform name (mac/linux/windows).</p> <code>getCommandsForCurrentPlatform</code> <p>Selects platform-specific commands from a dictionary.</p> <code>getInstallCondaCommands</code> <p>Generates commands to install micromamba if missing.</p> <code>getActivateCondaCommands</code> <p>Generates commands to install (if needed) and activate Conda.</p> <code>getActivateEnvironmentCommands</code> <p>Generates commands to activate the given environment</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>class CommandGenerator:\n    \"\"\"Generate Conda commands.\"\"\"\n\n    def __init__(self, settingsManager: SettingsManager, dependencyManager: DependencyManager):\n        self.settingsManager = settingsManager\n        self.dependencyManager = dependencyManager\n\n    def getShellHookCommands(self) -&gt; list[str]:\n        \"\"\"Generates shell commands for Conda initialization.\n\n        Returns:\n                OS-specific commands to activate Conda shell hooks.\n        \"\"\"\n        currentPath = Path.cwd().resolve()\n        condaPath, condaBinPath = self.settingsManager.getCondaPaths()\n        if platform.system() == \"Windows\":\n            return [\n                f'Set-Location -Path \"{condaPath}\"',\n                f'$Env:MAMBA_ROOT_PREFIX=\"{condaPath}\"',\n                f\".\\\\{condaBinPath} shell hook -s powershell | Out-String | Invoke-Expression\",\n                f'Set-Location -Path \"{currentPath}\"',\n            ]\n        else:\n            return [\n                f'cd \"{condaPath}\"',\n                f'export MAMBA_ROOT_PREFIX=\"{condaPath}\"',\n                f'eval \"$({condaBinPath} shell hook -s posix)\"',\n                f'cd \"{currentPath}\"',\n            ]\n\n    def createMambaConfigFile(self, condaPath):\n        \"\"\"Create Mamba config file .mambarc in condaPath, with nodefaults and conda-forge channels.\"\"\"\n        condaPath.mkdir(exist_ok=True, parents=True)\n        with open(condaPath / \".mambarc\", \"w\") as f:\n            mambaSettings = dict(\n                channel_priority=\"flexible\",\n                channels=[\"conda-forge\", \"nodefaults\"],\n                default_channels=[\"conda-forge\"],\n            )\n            yaml.safe_dump(mambaSettings, f)\n\n    def getPlatformCommonName(self) -&gt; str:\n        \"\"\"Gets common platform name (mac/linux/windows).\"\"\"\n        return \"mac\" if platform.system() == \"Darwin\" else platform.system().lower()\n\n    def toCommandsDict(self, commands: Commands) -&gt; CommandsDict:\n        return {\"all\": commands} if isinstance(commands, list) else commands\n\n    def getCommandsForCurrentPlatform(self, additionalCommands: Commands = {}) -&gt; list[str]:\n        \"\"\"Selects platform-specific commands from a dictionary.\n\n        Args:\n                additionalCommands: Dictionary mapping platforms to command lists (e.g. dict(all=[], linux=['wget \"http://something.cool\"']) ).\n\n        Returns:\n                Merged list of commands for 'all' and current platform.\n        \"\"\"\n        commands = []\n        if additionalCommands is None:\n            return commands\n        additionalCommandsDict = self.toCommandsDict(additionalCommands)\n        for name in [\"all\", self.getPlatformCommonName()]:\n            commands += additionalCommandsDict.get(name, [])\n        return commands\n\n    def getInstallCondaCommands(self) -&gt; list[str]:\n        \"\"\"Generates commands to install micromamba if missing.\n\n        Returns:\n                List of installation commands for the current OS.\n        \"\"\"\n        condaPath, condaBinPath = self.settingsManager.getCondaPaths()\n        if (condaPath / condaBinPath).exists():\n            return []\n        if platform.system() not in [\"Windows\", \"Linux\", \"Darwin\"]:\n            raise Exception(f\"Platform {platform.system()} is not supported.\")\n\n        self.createMambaConfigFile(condaPath)\n\n        commands = self.settingsManager.getProxyEnvironmentVariablesCommands()\n        proxyString = self.settingsManager.getProxyString()\n\n        if platform.system() == \"Windows\":\n            proxyCredentials = \"\"\n            if proxyString is not None:\n                match = re.search(r\"^[a-zA-Z]+://(.*?):(.*?)@\", proxyString)\n                if match:\n                    username, password = match.groups()\n                    commands += [\n                        f'$proxyUsername = \"{username}\"',\n                        f'$proxyPassword = \"{password}\"',\n                        \"$securePassword = ConvertTo-SecureString $proxyPassword -AsPlainText -Force\",\n                        \"$proxyCredentials = New-Object System.Management.Automation.PSCredential($proxyUsername, $securePassword)\",\n                    ]\n                    proxyCredentials = f\"-ProxyCredential $proxyCredentials\"\n            proxyArgs = f\"-Proxy {proxyString} {proxyCredentials}\" if proxyString is not None else \"\"\n            commands += [\n                f'Set-Location -Path \"{condaPath}\"',\n                f'echo \"Installing Visual C++ Redistributable if necessary...\"',\n                f'Invoke-WebRequest {proxyArgs} -URI \"https://aka.ms/vs/17/release/vc_redist.x64.exe\" -OutFile \"$env:Temp\\\\vc_redist.x64.exe\"; Start-Process \"$env:Temp\\\\vc_redist.x64.exe\" -ArgumentList \"/quiet /norestart\" -Wait; Remove-Item \"$env:Temp\\\\vc_redist.x64.exe\"',\n                f'echo \"Installing micromamba...\"',\n                f\"Invoke-Webrequest {proxyArgs} -URI https://github.com/mamba-org/micromamba-releases/releases/download/2.0.4-0/micromamba-win-64 -OutFile micromamba.exe\",\n            ]\n        else:\n            system = \"osx\" if platform.system() == \"Darwin\" else \"linux\"\n            machine = platform.machine()\n            machine = \"64\" if machine == \"x86_64\" else machine\n            proxyArgs = f'--proxy \"{proxyString}\"' if proxyString is not None else \"\"\n            commands += [\n                f'cd \"{condaPath}\"',\n                f'echo \"Installing micromamba...\"',\n                f\"curl {proxyArgs} -Ls https://micro.mamba.pm/api/micromamba/{system}-{machine}/latest | tar -xvj bin/micromamba\",\n            ]\n        commands += self.getShellHookCommands()\n        return commands\n\n    def getActivateCondaCommands(self) -&gt; list[str]:\n        \"\"\"Generates commands to install (if needed) and activate Conda.\"\"\"\n        commands = self.getInstallCondaCommands()\n        return commands + self.getShellHookCommands()\n\n    def getActivateEnvironmentCommands(\n        self, environment: str | None, additionalActivateCommands: Commands = {}\n    ) -&gt; list[str]:\n        \"\"\"Generates commands to activate the given environment\n\n        Args:\n                environment: Environment name to launch. If none, the resulting command list will be empty.\n                additionalActivateCommands: Platform-specific activation commands.\n\n        Returns:\n                List of commands to activate the environment\n        \"\"\"\n        if environment is None:\n            return []\n        commands = self.getActivateCondaCommands()\n        commands += [f\"{self.settingsManager.condaBin} activate {environment}\"]\n        return commands + self.getCommandsForCurrentPlatform(additionalActivateCommands)\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getShellHookCommands","title":"<code>getShellHookCommands()</code>","text":"<p>Generates shell commands for Conda initialization.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>OS-specific commands to activate Conda shell hooks.</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getShellHookCommands(self) -&gt; list[str]:\n    \"\"\"Generates shell commands for Conda initialization.\n\n    Returns:\n            OS-specific commands to activate Conda shell hooks.\n    \"\"\"\n    currentPath = Path.cwd().resolve()\n    condaPath, condaBinPath = self.settingsManager.getCondaPaths()\n    if platform.system() == \"Windows\":\n        return [\n            f'Set-Location -Path \"{condaPath}\"',\n            f'$Env:MAMBA_ROOT_PREFIX=\"{condaPath}\"',\n            f\".\\\\{condaBinPath} shell hook -s powershell | Out-String | Invoke-Expression\",\n            f'Set-Location -Path \"{currentPath}\"',\n        ]\n    else:\n        return [\n            f'cd \"{condaPath}\"',\n            f'export MAMBA_ROOT_PREFIX=\"{condaPath}\"',\n            f'eval \"$({condaBinPath} shell hook -s posix)\"',\n            f'cd \"{currentPath}\"',\n        ]\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.createMambaConfigFile","title":"<code>createMambaConfigFile(condaPath)</code>","text":"<p>Create Mamba config file .mambarc in condaPath, with nodefaults and conda-forge channels.</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def createMambaConfigFile(self, condaPath):\n    \"\"\"Create Mamba config file .mambarc in condaPath, with nodefaults and conda-forge channels.\"\"\"\n    condaPath.mkdir(exist_ok=True, parents=True)\n    with open(condaPath / \".mambarc\", \"w\") as f:\n        mambaSettings = dict(\n            channel_priority=\"flexible\",\n            channels=[\"conda-forge\", \"nodefaults\"],\n            default_channels=[\"conda-forge\"],\n        )\n        yaml.safe_dump(mambaSettings, f)\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getPlatformCommonName","title":"<code>getPlatformCommonName()</code>","text":"<p>Gets common platform name (mac/linux/windows).</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getPlatformCommonName(self) -&gt; str:\n    \"\"\"Gets common platform name (mac/linux/windows).\"\"\"\n    return \"mac\" if platform.system() == \"Darwin\" else platform.system().lower()\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getCommandsForCurrentPlatform","title":"<code>getCommandsForCurrentPlatform(additionalCommands={})</code>","text":"<p>Selects platform-specific commands from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>additionalCommands</code> <code>Commands</code> <p>Dictionary mapping platforms to command lists (e.g. dict(all=[], linux=['wget \"http://something.cool\"']) ).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Merged list of commands for 'all' and current platform.</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getCommandsForCurrentPlatform(self, additionalCommands: Commands = {}) -&gt; list[str]:\n    \"\"\"Selects platform-specific commands from a dictionary.\n\n    Args:\n            additionalCommands: Dictionary mapping platforms to command lists (e.g. dict(all=[], linux=['wget \"http://something.cool\"']) ).\n\n    Returns:\n            Merged list of commands for 'all' and current platform.\n    \"\"\"\n    commands = []\n    if additionalCommands is None:\n        return commands\n    additionalCommandsDict = self.toCommandsDict(additionalCommands)\n    for name in [\"all\", self.getPlatformCommonName()]:\n        commands += additionalCommandsDict.get(name, [])\n    return commands\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getInstallCondaCommands","title":"<code>getInstallCondaCommands()</code>","text":"<p>Generates commands to install micromamba if missing.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of installation commands for the current OS.</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getInstallCondaCommands(self) -&gt; list[str]:\n    \"\"\"Generates commands to install micromamba if missing.\n\n    Returns:\n            List of installation commands for the current OS.\n    \"\"\"\n    condaPath, condaBinPath = self.settingsManager.getCondaPaths()\n    if (condaPath / condaBinPath).exists():\n        return []\n    if platform.system() not in [\"Windows\", \"Linux\", \"Darwin\"]:\n        raise Exception(f\"Platform {platform.system()} is not supported.\")\n\n    self.createMambaConfigFile(condaPath)\n\n    commands = self.settingsManager.getProxyEnvironmentVariablesCommands()\n    proxyString = self.settingsManager.getProxyString()\n\n    if platform.system() == \"Windows\":\n        proxyCredentials = \"\"\n        if proxyString is not None:\n            match = re.search(r\"^[a-zA-Z]+://(.*?):(.*?)@\", proxyString)\n            if match:\n                username, password = match.groups()\n                commands += [\n                    f'$proxyUsername = \"{username}\"',\n                    f'$proxyPassword = \"{password}\"',\n                    \"$securePassword = ConvertTo-SecureString $proxyPassword -AsPlainText -Force\",\n                    \"$proxyCredentials = New-Object System.Management.Automation.PSCredential($proxyUsername, $securePassword)\",\n                ]\n                proxyCredentials = f\"-ProxyCredential $proxyCredentials\"\n        proxyArgs = f\"-Proxy {proxyString} {proxyCredentials}\" if proxyString is not None else \"\"\n        commands += [\n            f'Set-Location -Path \"{condaPath}\"',\n            f'echo \"Installing Visual C++ Redistributable if necessary...\"',\n            f'Invoke-WebRequest {proxyArgs} -URI \"https://aka.ms/vs/17/release/vc_redist.x64.exe\" -OutFile \"$env:Temp\\\\vc_redist.x64.exe\"; Start-Process \"$env:Temp\\\\vc_redist.x64.exe\" -ArgumentList \"/quiet /norestart\" -Wait; Remove-Item \"$env:Temp\\\\vc_redist.x64.exe\"',\n            f'echo \"Installing micromamba...\"',\n            f\"Invoke-Webrequest {proxyArgs} -URI https://github.com/mamba-org/micromamba-releases/releases/download/2.0.4-0/micromamba-win-64 -OutFile micromamba.exe\",\n        ]\n    else:\n        system = \"osx\" if platform.system() == \"Darwin\" else \"linux\"\n        machine = platform.machine()\n        machine = \"64\" if machine == \"x86_64\" else machine\n        proxyArgs = f'--proxy \"{proxyString}\"' if proxyString is not None else \"\"\n        commands += [\n            f'cd \"{condaPath}\"',\n            f'echo \"Installing micromamba...\"',\n            f\"curl {proxyArgs} -Ls https://micro.mamba.pm/api/micromamba/{system}-{machine}/latest | tar -xvj bin/micromamba\",\n        ]\n    commands += self.getShellHookCommands()\n    return commands\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getActivateCondaCommands","title":"<code>getActivateCondaCommands()</code>","text":"<p>Generates commands to install (if needed) and activate Conda.</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getActivateCondaCommands(self) -&gt; list[str]:\n    \"\"\"Generates commands to install (if needed) and activate Conda.\"\"\"\n    commands = self.getInstallCondaCommands()\n    return commands + self.getShellHookCommands()\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getActivateEnvironmentCommands","title":"<code>getActivateEnvironmentCommands(environment, additionalActivateCommands={})</code>","text":"<p>Generates commands to activate the given environment</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>str | None</code> <p>Environment name to launch. If none, the resulting command list will be empty.</p> required <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of commands to activate the environment</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getActivateEnvironmentCommands(\n    self, environment: str | None, additionalActivateCommands: Commands = {}\n) -&gt; list[str]:\n    \"\"\"Generates commands to activate the given environment\n\n    Args:\n            environment: Environment name to launch. If none, the resulting command list will be empty.\n            additionalActivateCommands: Platform-specific activation commands.\n\n    Returns:\n            List of commands to activate the environment\n    \"\"\"\n    if environment is None:\n        return []\n    commands = self.getActivateCondaCommands()\n    commands += [f\"{self.settingsManager.condaBin} activate {environment}\"]\n    return commands + self.getCommandsForCurrentPlatform(additionalActivateCommands)\n</code></pre>"},{"location":"reference/wetlands/_internal/dependency_manager/","title":"Dependency manager","text":""},{"location":"reference/wetlands/_internal/dependency_manager/#wetlands._internal.dependency_manager.DependencyManager","title":"<code>DependencyManager</code>","text":"<p>Manage pip and conda dependencies.</p> <p>Methods:</p> Name Description <code>formatDependencies</code> <p>Formats dependencies for installation with platform checks.</p> <code>getInstallDependenciesCommands</code> <p>Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.getActivateCondaCommands() first.</p> Source code in <code>wetlands/_internal/dependency_manager.py</code> <pre><code>class DependencyManager:\n    \"\"\"Manage pip and conda dependencies.\"\"\"\n\n    def __init__(self, settingsManager: SettingsManager):\n        self.installedPackages: dict[str, dict[str, str]] = {}\n        self.settingsManager = settingsManager\n\n    def _platformCondaFormat(self) -&gt; str:\n        \"\"\"Get conda-compatible platform string (e.g., 'linux-64', 'osx-arm64', 'win-64').\"\"\"\n        machine = platform.machine()\n        machine = \"64\" if machine == \"x86_64\" or machine == \"AMD64\" else machine\n        system = dict(Darwin=\"osx\", Windows=\"win\", Linux=\"linux\")[platform.system()]\n        return f\"{system}-{machine}\"\n\n    def formatDependencies(\n        self,\n        package_manager: str,\n        dependencies: Dependencies,\n        raiseIncompatibilityError: bool = True,\n        quotes: bool = True,\n    ) -&gt; tuple[list[str], list[str], bool]:\n        \"\"\"Formats dependencies for installation with platform checks.\n\n        Args:\n                package_manager: 'conda' or 'pip'.\n                dependencies: Dependencies to process.\n                raiseIncompatibilityError: Whether to raise on incompatible platforms.\n                quotes: Whether to put dependencies in quotes (required when installing extras on mac, e.g. `pip install \"napari[pyqt5]\"`)\n\n        Returns:\n                Tuple of (dependencies, no-deps dependencies, has_dependencies).\n\n        Raises:\n                IncompatibilityException: For non-optional incompatible dependencies.\n        \"\"\"\n        dependencyList: list[str | Dependency] = dependencies.get(package_manager, [])  # type: ignore\n        finalDependencies: list[str] = []\n        finalDependenciesNoDeps: list[str] = []\n        for dependency in dependencyList:\n            if isinstance(dependency, str):\n                finalDependencies.append(dependency)\n            else:\n                currentPlatform = self._platformCondaFormat()\n                platforms = dependency.get(\"platforms\", \"all\")\n                if (\n                    currentPlatform in platforms\n                    or platforms == \"all\"\n                    or len(platforms) == 0\n                    or not raiseIncompatibilityError\n                ):\n                    if \"dependencies\" not in dependency or dependency[\"dependencies\"]:\n                        finalDependencies.append(dependency[\"name\"])\n                    else:\n                        finalDependenciesNoDeps.append(dependency[\"name\"])\n                elif not dependency.get(\"optional\", False):\n                    platformsString = \", \".join(platforms)\n                    raise IncompatibilityException(\n                        f\"Error: the library {dependency['name']} is not available on this platform ({currentPlatform}). It is only available on the following platforms: {platformsString}.\"\n                    )\n        if quotes:\n            finalDependencies = [f'\"{d}\"' for d in finalDependencies]\n            finalDependenciesNoDeps = [f'\"{d}\"' for d in finalDependenciesNoDeps]\n        return (\n            finalDependencies,\n            finalDependenciesNoDeps,\n            len(finalDependencies) + len(finalDependenciesNoDeps) &gt; 0,\n        )\n\n    def getInstallDependenciesCommands(self, environment: str | None, dependencies: Dependencies) -&gt; list[str]:\n        \"\"\"Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.getActivateCondaCommands() first.\n\n        Args:\n                environment: Target environment name. If none, no conda environment will be activated, only pip dependencies will be installed in the current python environemnt ; conda dependencies will be ignored.\n                dependencies: Dependencies to install.\n\n        Returns:\n                list of installation commands.\n\n        Raises:\n                Exception: If pip dependencies contain Conda channel syntax.\n        \"\"\"\n        condaDependencies, condaDependenciesNoDeps, hasCondaDependencies = self.formatDependencies(\n            \"conda\", dependencies\n        )\n        pipDependencies, pipDependenciesNoDeps, hasPipDependencies = self.formatDependencies(\"pip\", dependencies)\n\n        if hasCondaDependencies and not environment:\n            raise Exception(\n                \"Conda dependencies can only be installed in a Conda environment. Please provide an existing conda environment to install dependencies.\"\n            )\n        if any(\"::\" in d for d in pipDependencies + pipDependenciesNoDeps):\n            raise Exception(\n                f'One pip dependency has a channel specifier \"::\". Is it a conda dependency?\\n\\n({dependencies.get(\"pip\")})'\n            )\n        installDepsCommands = self.settingsManager.getProxyEnvironmentVariablesCommands()\n        installDepsCommands += (\n            [\n                f'echo \"Activating environment {environment}...\"',\n                f\"{self.settingsManager.condaBin} activate {environment}\",\n            ]\n            if environment and (hasCondaDependencies or hasPipDependencies)\n            else []\n        )\n        installDepsCommands += (\n            [\n                f'echo \"Installing conda dependencies...\"',\n                f\"{self.settingsManager.condaBinConfig} install {' '.join(condaDependencies)} -y\",\n            ]\n            if len(condaDependencies) &gt; 0\n            else []\n        )\n        installDepsCommands += (\n            [\n                f'echo \"Installing conda dependencies without their dependencies...\"',\n                f\"{self.settingsManager.condaBinConfig} install --no-deps {' '.join(condaDependenciesNoDeps)} -y\",\n            ]\n            if len(condaDependenciesNoDeps) &gt; 0\n            else []\n        )\n        proxyString = self.settingsManager.getProxyString()\n        proxyArgs = f\"--proxy {proxyString}\" if proxyString is not None else \"\"\n        installDepsCommands += (\n            [\n                f'echo \"Installing pip dependencies...\"',\n                f\"pip install {proxyArgs} {' '.join(pipDependencies)}\",\n            ]\n            if len(pipDependencies) &gt; 0\n            else []\n        )\n        installDepsCommands += (\n            [\n                f'echo \"Installing pip dependencies without their dependencies...\"',\n                f\"pip install {proxyArgs} --no-deps {' '.join(pipDependenciesNoDeps)}\",\n            ]\n            if len(pipDependenciesNoDeps) &gt; 0\n            else []\n        )\n        return installDepsCommands\n</code></pre>"},{"location":"reference/wetlands/_internal/dependency_manager/#wetlands._internal.dependency_manager.DependencyManager.formatDependencies","title":"<code>formatDependencies(package_manager, dependencies, raiseIncompatibilityError=True, quotes=True)</code>","text":"<p>Formats dependencies for installation with platform checks.</p> <p>Parameters:</p> Name Type Description Default <code>package_manager</code> <code>str</code> <p>'conda' or 'pip'.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to process.</p> required <code>raiseIncompatibilityError</code> <code>bool</code> <p>Whether to raise on incompatible platforms.</p> <code>True</code> <code>quotes</code> <code>bool</code> <p>Whether to put dependencies in quotes (required when installing extras on mac, e.g. <code>pip install \"napari[pyqt5]\"</code>)</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[list[str], list[str], bool]</code> <p>Tuple of (dependencies, no-deps dependencies, has_dependencies).</p> <p>Raises:</p> Type Description <code>IncompatibilityException</code> <p>For non-optional incompatible dependencies.</p> Source code in <code>wetlands/_internal/dependency_manager.py</code> <pre><code>def formatDependencies(\n    self,\n    package_manager: str,\n    dependencies: Dependencies,\n    raiseIncompatibilityError: bool = True,\n    quotes: bool = True,\n) -&gt; tuple[list[str], list[str], bool]:\n    \"\"\"Formats dependencies for installation with platform checks.\n\n    Args:\n            package_manager: 'conda' or 'pip'.\n            dependencies: Dependencies to process.\n            raiseIncompatibilityError: Whether to raise on incompatible platforms.\n            quotes: Whether to put dependencies in quotes (required when installing extras on mac, e.g. `pip install \"napari[pyqt5]\"`)\n\n    Returns:\n            Tuple of (dependencies, no-deps dependencies, has_dependencies).\n\n    Raises:\n            IncompatibilityException: For non-optional incompatible dependencies.\n    \"\"\"\n    dependencyList: list[str | Dependency] = dependencies.get(package_manager, [])  # type: ignore\n    finalDependencies: list[str] = []\n    finalDependenciesNoDeps: list[str] = []\n    for dependency in dependencyList:\n        if isinstance(dependency, str):\n            finalDependencies.append(dependency)\n        else:\n            currentPlatform = self._platformCondaFormat()\n            platforms = dependency.get(\"platforms\", \"all\")\n            if (\n                currentPlatform in platforms\n                or platforms == \"all\"\n                or len(platforms) == 0\n                or not raiseIncompatibilityError\n            ):\n                if \"dependencies\" not in dependency or dependency[\"dependencies\"]:\n                    finalDependencies.append(dependency[\"name\"])\n                else:\n                    finalDependenciesNoDeps.append(dependency[\"name\"])\n            elif not dependency.get(\"optional\", False):\n                platformsString = \", \".join(platforms)\n                raise IncompatibilityException(\n                    f\"Error: the library {dependency['name']} is not available on this platform ({currentPlatform}). It is only available on the following platforms: {platformsString}.\"\n                )\n    if quotes:\n        finalDependencies = [f'\"{d}\"' for d in finalDependencies]\n        finalDependenciesNoDeps = [f'\"{d}\"' for d in finalDependenciesNoDeps]\n    return (\n        finalDependencies,\n        finalDependenciesNoDeps,\n        len(finalDependencies) + len(finalDependenciesNoDeps) &gt; 0,\n    )\n</code></pre>"},{"location":"reference/wetlands/_internal/dependency_manager/#wetlands._internal.dependency_manager.DependencyManager.getInstallDependenciesCommands","title":"<code>getInstallDependenciesCommands(environment, dependencies)</code>","text":"<p>Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.getActivateCondaCommands() first.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>str | None</code> <p>Target environment name. If none, no conda environment will be activated, only pip dependencies will be installed in the current python environemnt ; conda dependencies will be ignored.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list of installation commands.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If pip dependencies contain Conda channel syntax.</p> Source code in <code>wetlands/_internal/dependency_manager.py</code> <pre><code>def getInstallDependenciesCommands(self, environment: str | None, dependencies: Dependencies) -&gt; list[str]:\n    \"\"\"Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.getActivateCondaCommands() first.\n\n    Args:\n            environment: Target environment name. If none, no conda environment will be activated, only pip dependencies will be installed in the current python environemnt ; conda dependencies will be ignored.\n            dependencies: Dependencies to install.\n\n    Returns:\n            list of installation commands.\n\n    Raises:\n            Exception: If pip dependencies contain Conda channel syntax.\n    \"\"\"\n    condaDependencies, condaDependenciesNoDeps, hasCondaDependencies = self.formatDependencies(\n        \"conda\", dependencies\n    )\n    pipDependencies, pipDependenciesNoDeps, hasPipDependencies = self.formatDependencies(\"pip\", dependencies)\n\n    if hasCondaDependencies and not environment:\n        raise Exception(\n            \"Conda dependencies can only be installed in a Conda environment. Please provide an existing conda environment to install dependencies.\"\n        )\n    if any(\"::\" in d for d in pipDependencies + pipDependenciesNoDeps):\n        raise Exception(\n            f'One pip dependency has a channel specifier \"::\". Is it a conda dependency?\\n\\n({dependencies.get(\"pip\")})'\n        )\n    installDepsCommands = self.settingsManager.getProxyEnvironmentVariablesCommands()\n    installDepsCommands += (\n        [\n            f'echo \"Activating environment {environment}...\"',\n            f\"{self.settingsManager.condaBin} activate {environment}\",\n        ]\n        if environment and (hasCondaDependencies or hasPipDependencies)\n        else []\n    )\n    installDepsCommands += (\n        [\n            f'echo \"Installing conda dependencies...\"',\n            f\"{self.settingsManager.condaBinConfig} install {' '.join(condaDependencies)} -y\",\n        ]\n        if len(condaDependencies) &gt; 0\n        else []\n    )\n    installDepsCommands += (\n        [\n            f'echo \"Installing conda dependencies without their dependencies...\"',\n            f\"{self.settingsManager.condaBinConfig} install --no-deps {' '.join(condaDependenciesNoDeps)} -y\",\n        ]\n        if len(condaDependenciesNoDeps) &gt; 0\n        else []\n    )\n    proxyString = self.settingsManager.getProxyString()\n    proxyArgs = f\"--proxy {proxyString}\" if proxyString is not None else \"\"\n    installDepsCommands += (\n        [\n            f'echo \"Installing pip dependencies...\"',\n            f\"pip install {proxyArgs} {' '.join(pipDependencies)}\",\n        ]\n        if len(pipDependencies) &gt; 0\n        else []\n    )\n    installDepsCommands += (\n        [\n            f'echo \"Installing pip dependencies without their dependencies...\"',\n            f\"pip install {proxyArgs} --no-deps {' '.join(pipDependenciesNoDeps)}\",\n        ]\n        if len(pipDependenciesNoDeps) &gt; 0\n        else []\n    )\n    return installDepsCommands\n</code></pre>"},{"location":"reference/wetlands/_internal/exceptions/","title":"Exceptions","text":""},{"location":"reference/wetlands/_internal/exceptions/#wetlands._internal.exceptions.ExecutionException","title":"<code>ExecutionException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the environment raises an error when executing the requested function.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>explanation of the error</p> Source code in <code>wetlands/_internal/exceptions.py</code> <pre><code>class ExecutionException(Exception):\n    \"\"\"Exception raised when the environment raises an error when executing the requested function.\n\n    Attributes:\n            message: explanation of the error\n    \"\"\"\n\n    def __init__(self, message):\n        super().__init__(message)\n        self.exception = message[\"exception\"] if \"exception\" in message else None\n        self.traceback = message[\"traceback\"] if \"traceback\" in message else None\n</code></pre>"},{"location":"reference/wetlands/_internal/module_executor/","title":"Module executor","text":"<p>This script launches a server inside a specified conda environment. It listens on a dynamically assigned local port for incoming execution commands sent via a multiprocessing connection.</p> <p>Clients can send instructions to: - Dynamically import a Python module from a specified path - Execute a given function from that module with optional arguments - Receive the result or any errors from the execution</p> <p>Designed to be run within isolated environments for sandboxed execution of Python code modules.</p> <p>Functions:</p> Name Description <code>getMessage</code> <p>Waits for and receives a message from the given connection.</p> <code>functionExecutor</code> <p>Executes a specified function from a dynamically imported module in a thread-safe way.</p> <code>launchListener</code> <p>Launches a listener on a random available port on localhost.</p>"},{"location":"reference/wetlands/_internal/module_executor/#wetlands._internal.module_executor.getMessage","title":"<code>getMessage(connection)</code>","text":"<p>Waits for and receives a message from the given connection.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>A multiprocessing connection object.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The message received from the connection.</p> Source code in <code>wetlands/_internal/module_executor.py</code> <pre><code>def getMessage(connection: Connection) -&gt; dict:\n    \"\"\"\n    Waits for and receives a message from the given connection.\n\n    Args:\n        connection: A multiprocessing connection object.\n\n    Returns:\n        The message received from the connection.\n    \"\"\"\n    logger.debug(f\"Waiting for message...\")\n    return connection.recv()\n</code></pre>"},{"location":"reference/wetlands/_internal/module_executor/#wetlands._internal.module_executor.functionExecutor","title":"<code>functionExecutor(lock, connection, message)</code>","text":"<p>Executes a specified function from a dynamically imported module in a thread-safe way.</p> <p>Parameters:</p> Name Type Description Default <code>lock</code> <code>Lock</code> <p>Lock to synchronize access to the connection.</p> required <code>connection</code> <code>Connection</code> <p>Connection object to send results or errors.</p> required <code>message</code> <code>dict</code> <p>Dictionary containing module path, function name, and optional args/kwargs.</p> required Expected message format <p>{     \"modulePath\": \"path/to/module.py\",     \"function\": \"function_name\",     \"args\": [...],     \"kwargs\": {...} }</p> Sends <ul> <li>On success: {'action': 'execution finished', 'message': 'process execution done', 'result': result}</li> <li>On failure: {'action': 'error', 'exception': str(e), 'traceback': [...]}</li> </ul> Source code in <code>wetlands/_internal/module_executor.py</code> <pre><code>def functionExecutor(lock: threading.Lock, connection: Connection, message: dict):\n    \"\"\"\n    Executes a specified function from a dynamically imported module in a thread-safe way.\n\n    Args:\n        lock (threading.Lock): Lock to synchronize access to the connection.\n        connection: Connection object to send results or errors.\n        message (dict): Dictionary containing module path, function name, and optional args/kwargs.\n\n    Expected message format:\n        {\n            \"modulePath\": \"path/to/module.py\",\n            \"function\": \"function_name\",\n            \"args\": [...],\n            \"kwargs\": {...}\n        }\n\n    Sends:\n        - On success: {'action': 'execution finished', 'message': 'process execution done', 'result': result}\n        - On failure: {'action': 'error', 'exception': str(e), 'traceback': [...]}\n    \"\"\"\n    try:\n        modulePath = Path(message[\"modulePath\"])\n        sys.path.append(str(modulePath.parent))\n        module = import_module(modulePath.stem)\n        if not hasattr(module, message[\"function\"]):\n            raise Exception(f\"Module {modulePath} has no function {message['function']}.\")\n        args = message.get(\"args\", [])\n        kwargs = message.get(\"kwargs\", {})\n        result = getattr(module, message[\"function\"])(*args, **kwargs)\n        logger.info(f\"Executed\")\n        with lock:\n            connection.send(\n                dict(\n                    action=\"execution finished\",\n                    message=\"process execution done\",\n                    result=result,\n                )\n            )\n    except Exception as e:\n        with lock:\n            connection.send(\n                dict(\n                    action=\"error\",\n                    exception=str(e),\n                    traceback=traceback.format_tb(e.__traceback__),\n                )\n            )\n</code></pre>"},{"location":"reference/wetlands/_internal/module_executor/#wetlands._internal.module_executor.launchListener","title":"<code>launchListener()</code>","text":"<p>Launches a listener on a random available port on localhost. Waits for client connections and handles incoming execution or exit messages.</p> Workflow <ul> <li>Prints the listening port once ready.</li> <li>Accepts a single connection at a time.</li> <li>Handles incoming messages in a loop.</li> <li>For 'execute' messages, spawns a new thread to run the function.</li> <li>For 'exit' messages, acknowledges and stops the listener.</li> <li>On errors, sends error details back to the client.</li> </ul> Note <p>The listener automatically closes after receiving an 'exit' command.</p> Source code in <code>wetlands/_internal/module_executor.py</code> <pre><code>def launchListener():\n    \"\"\"\n    Launches a listener on a random available port on localhost.\n    Waits for client connections and handles incoming execution or exit messages.\n\n    Workflow:\n        - Prints the listening port once ready.\n        - Accepts a single connection at a time.\n        - Handles incoming messages in a loop.\n        - For 'execute' messages, spawns a new thread to run the function.\n        - For 'exit' messages, acknowledges and stops the listener.\n        - On errors, sends error details back to the client.\n\n    Note:\n        The listener automatically closes after receiving an 'exit' command.\n    \"\"\"\n    lock = threading.Lock()\n    with Listener((\"localhost\", 0)) as listener:\n        while True:\n            # Print ready message for the environment manager (it can now open a client to send messages)\n            print(f\"Listening port {listener.address[1]}\")\n            with listener.accept() as connection:\n                logger.debug(f\"Connection accepted {listener.address}\")\n                message = \"\"\n                try:\n                    while message := getMessage(connection):\n                        logger.debug(f\"Got message: {message}\")\n                        if message[\"action\"] == \"execute\":\n                            logger.info(f\"Execute {message['modulePath']}.{message['function']}({message['args']})\")\n\n                            thread = threading.Thread(\n                                target=functionExecutor,\n                                args=(lock, connection, message),\n                            )\n                            thread.start()\n\n                        if message[\"action\"] == \"exit\":\n                            logger.info(f\"exit\")\n                            with lock:\n                                connection.send(dict(action=\"exited\"))\n                            listener.close()\n                            return\n                except Exception as e:\n                    logger.error(\"Caught exception:\")\n                    logger.error(e)\n                    logger.error(e.args)\n                    for line in traceback.format_tb(e.__traceback__):\n                        logger.error(line)\n                    logger.error(message)\n                    with lock:\n                        connection.send(\n                            dict(\n                                action=\"error\",\n                                exception=str(e),\n                                traceback=traceback.format_tb(e.__traceback__),\n                            )\n                        )\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/","title":"Settings manager","text":""},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager","title":"<code>SettingsManager</code>","text":"<p>Methods:</p> Name Description <code>setCondaPath</code> <p>Updates the micromamba path and loads proxy settings if exists.</p> <code>setProxies</code> <p>Configures proxy settings for Conda operations (see Using Anaconda behind a company proxy).</p> <code>getCondaPaths</code> <p>Gets micromamba root path and binary path.</p> <code>getProxyEnvironmentVariablesCommands</code> <p>Generates proxy environment variable commands.</p> <code>getProxyString</code> <p>Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>class SettingsManager:\n    condaBin = \"micromamba\"\n    condaBinConfig = \"micromamba --rc-file ~/.mambarc\"\n    proxies: dict[str, str] | None = None\n\n    def __init__(self, condaPath: str | Path = Path(\"micromamba\")) -&gt; None:\n        self.setCondaPath(condaPath)\n\n    def setCondaPath(self, condaPath: str | Path) -&gt; None:\n        \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n        Args:\n                condaPath: New path to micromamba binary.\n\n        Side Effects:\n                Updates condaBinConfig and proxies from the .mambarc file.\n        \"\"\"\n        self.condaPath = Path(condaPath).resolve()\n        condaConfigPath = self.condaPath / \".mambarc\"\n        self.condaBinConfig = f'{self.condaBin} --rc-file \"{condaConfigPath}\"'\n        import yaml\n\n        if condaConfigPath.exists():\n            with open(condaConfigPath, \"r\") as f:\n                condaConfig = yaml.safe_load(f)\n                if condaConfig is not None and \"proxies\" in condaConfig:\n                    self.proxies = condaConfig[\"proxies\"]\n\n    def setProxies(self, proxies: dict[str, str]) -&gt; None:\n        \"\"\"Configures proxy settings for Conda operations (see [Using Anaconda behind a company proxy](https://www.anaconda.com/docs/tools/working-with-conda/reference/proxy)).\n\n        Args:\n                proxies: Proxy configuration dictionary (e.g., {'http': 'http://username:password@corp.com:8080', 'https': 'https://username:password@corp.com:8080'}).\n\n        Side Effects:\n                Updates .mambarc configuration file with proxy settings.\n        \"\"\"\n        self.proxies = proxies\n        condaConfigPath = self.condaPath / \".mambarc\"\n        condaConfig = dict()\n        import yaml\n\n        if condaConfigPath.exists():\n            with open(condaConfigPath, \"r\") as f:\n                condaConfig = yaml.safe_load(f)\n            if proxies:\n                condaConfig[\"proxy_servers\"] = proxies\n            else:\n                del condaConfig[\"proxy_servers\"]\n            with open(condaConfigPath, \"w\") as f:\n                yaml.safe_dump(condaConfig, f)\n\n    def getCondaPaths(self) -&gt; tuple[Path, Path]:\n        \"\"\"Gets micromamba root path and binary path.\n\n        Returns:\n                Tuple of (conda directory path, binary relative path).\n        \"\"\"\n        return self.condaPath.resolve(), Path(\"bin/micromamba\" if platform.system() != \"Windows\" else \"micromamba.exe\")\n\n    def getProxyEnvironmentVariablesCommands(self) -&gt; list[str]:\n        \"\"\"Generates proxy environment variable commands.\n\n        Returns:\n                List of OS-specific proxy export commands.\n        \"\"\"\n        if self.proxies is None:\n            return []\n        return [\n            f'export {name.lower()}_proxy=\"{value}\"'\n            if platform.system() != \"Windows\"\n            else f'$Env:{name.lower()}_proxy=\"{value}\"'\n            for name, value in self.proxies.items()\n        ]\n\n    def getProxyString(self) -&gt; str | None:\n        \"\"\"Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).\"\"\"\n        if self.proxies is None:\n            return None\n        return self.proxies.get(\"https\", self.proxies.get(\"http\", None))\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.setCondaPath","title":"<code>setCondaPath(condaPath)</code>","text":"<p>Updates the micromamba path and loads proxy settings if exists.</p> <p>Parameters:</p> Name Type Description Default <code>condaPath</code> <code>str | Path</code> <p>New path to micromamba binary.</p> required Side Effects <p>Updates condaBinConfig and proxies from the .mambarc file.</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def setCondaPath(self, condaPath: str | Path) -&gt; None:\n    \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n    Args:\n            condaPath: New path to micromamba binary.\n\n    Side Effects:\n            Updates condaBinConfig and proxies from the .mambarc file.\n    \"\"\"\n    self.condaPath = Path(condaPath).resolve()\n    condaConfigPath = self.condaPath / \".mambarc\"\n    self.condaBinConfig = f'{self.condaBin} --rc-file \"{condaConfigPath}\"'\n    import yaml\n\n    if condaConfigPath.exists():\n        with open(condaConfigPath, \"r\") as f:\n            condaConfig = yaml.safe_load(f)\n            if condaConfig is not None and \"proxies\" in condaConfig:\n                self.proxies = condaConfig[\"proxies\"]\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.setProxies","title":"<code>setProxies(proxies)</code>","text":"<p>Configures proxy settings for Conda operations (see Using Anaconda behind a company proxy).</p> <p>Parameters:</p> Name Type Description Default <code>proxies</code> <code>dict[str, str]</code> <p>Proxy configuration dictionary (e.g., {'http': 'http://username:password@corp.com:8080', 'https': 'https://username:password@corp.com:8080'}).</p> required Side Effects <p>Updates .mambarc configuration file with proxy settings.</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def setProxies(self, proxies: dict[str, str]) -&gt; None:\n    \"\"\"Configures proxy settings for Conda operations (see [Using Anaconda behind a company proxy](https://www.anaconda.com/docs/tools/working-with-conda/reference/proxy)).\n\n    Args:\n            proxies: Proxy configuration dictionary (e.g., {'http': 'http://username:password@corp.com:8080', 'https': 'https://username:password@corp.com:8080'}).\n\n    Side Effects:\n            Updates .mambarc configuration file with proxy settings.\n    \"\"\"\n    self.proxies = proxies\n    condaConfigPath = self.condaPath / \".mambarc\"\n    condaConfig = dict()\n    import yaml\n\n    if condaConfigPath.exists():\n        with open(condaConfigPath, \"r\") as f:\n            condaConfig = yaml.safe_load(f)\n        if proxies:\n            condaConfig[\"proxy_servers\"] = proxies\n        else:\n            del condaConfig[\"proxy_servers\"]\n        with open(condaConfigPath, \"w\") as f:\n            yaml.safe_dump(condaConfig, f)\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.getCondaPaths","title":"<code>getCondaPaths()</code>","text":"<p>Gets micromamba root path and binary path.</p> <p>Returns:</p> Type Description <code>tuple[Path, Path]</code> <p>Tuple of (conda directory path, binary relative path).</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def getCondaPaths(self) -&gt; tuple[Path, Path]:\n    \"\"\"Gets micromamba root path and binary path.\n\n    Returns:\n            Tuple of (conda directory path, binary relative path).\n    \"\"\"\n    return self.condaPath.resolve(), Path(\"bin/micromamba\" if platform.system() != \"Windows\" else \"micromamba.exe\")\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.getProxyEnvironmentVariablesCommands","title":"<code>getProxyEnvironmentVariablesCommands()</code>","text":"<p>Generates proxy environment variable commands.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of OS-specific proxy export commands.</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def getProxyEnvironmentVariablesCommands(self) -&gt; list[str]:\n    \"\"\"Generates proxy environment variable commands.\n\n    Returns:\n            List of OS-specific proxy export commands.\n    \"\"\"\n    if self.proxies is None:\n        return []\n    return [\n        f'export {name.lower()}_proxy=\"{value}\"'\n        if platform.system() != \"Windows\"\n        else f'$Env:{name.lower()}_proxy=\"{value}\"'\n        for name, value in self.proxies.items()\n    ]\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.getProxyString","title":"<code>getProxyString()</code>","text":"<p>Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def getProxyString(self) -&gt; str | None:\n    \"\"\"Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).\"\"\"\n    if self.proxies is None:\n        return None\n    return self.proxies.get(\"https\", self.proxies.get(\"http\", None))\n</code></pre>"}]}